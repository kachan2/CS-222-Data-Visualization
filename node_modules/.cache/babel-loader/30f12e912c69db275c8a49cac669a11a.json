{"ast":null,"code":"import { Encoding } from '@syncfusion/ej2-file-utils';\n/**\n * array literal codes\n */\nvar ARR_LITERAL_CODES = new Int16Array(286);\nvar ARR_LITERAL_LENGTHS = new Uint8Array(286);\nvar ARR_DISTANCE_CODES = new Int16Array(30);\nvar ARR_DISTANCE_LENGTHS = new Uint8Array(30);\n/**\n * represent compression stream writer\n * ```typescript\n * let compressedWriter = new CompressedStreamWriter();\n * let text: string = 'Hello world!!!';\n * compressedWriter.write(text, 0, text.length);\n * compressedWriter.close();\n * ```\n */\nvar CompressedStreamWriter = /** @class */function () {\n  /**\n   * Initializes compressor and writes ZLib header if needed.\n   * @param {boolean} noWrap - optional if true, ZLib header and checksum will not be written.\n   */\n  function CompressedStreamWriter(noWrap) {\n    this.pendingBuffer = new Uint8Array(1 << 16);\n    this.pendingBufLength = 0;\n    this.pendingBufCache = 0;\n    this.pendingBufBitsInCache = 0;\n    this.bufferPosition = 0;\n    this.extraBits = 0;\n    this.currentHash = 0;\n    this.matchStart = 0;\n    this.matchLength = 0;\n    this.matchPrevAvail = false;\n    this.blockStart = 0;\n    this.stringStart = 0;\n    this.lookAhead = 0;\n    this.totalBytesIn = 0;\n    this.inputOffset = 0;\n    this.inputEnd = 0;\n    this.windowSize = 1 << 15;\n    this.windowMask = this.windowSize - 1;\n    this.hashSize = 1 << 15;\n    this.hashMask = this.hashSize - 1;\n    this.hashShift = Math.floor((15 + 3 - 1) / 3);\n    this.maxDist = this.windowSize - 262;\n    this.checkSum = 1;\n    this.noWrap = false;\n    if (!CompressedStreamWriter.isHuffmanTreeInitiated) {\n      CompressedStreamWriter.initHuffmanTree();\n      CompressedStreamWriter.isHuffmanTreeInitiated = true;\n    }\n    this.treeLiteral = new CompressorHuffmanTree(this, 286, 257, 15);\n    this.treeDistances = new CompressorHuffmanTree(this, 30, 1, 15);\n    this.treeCodeLengths = new CompressorHuffmanTree(this, 19, 4, 7);\n    this.arrDistances = new Uint16Array(1 << 14);\n    this.arrLiterals = new Uint8Array(1 << 14);\n    this.stream = [];\n    this.dataWindow = new Uint8Array(2 * this.windowSize);\n    this.hashHead = new Int16Array(this.hashSize);\n    this.hashPrevious = new Int16Array(this.windowSize);\n    this.blockStart = this.stringStart = 1;\n    this.noWrap = noWrap;\n    if (!noWrap) {\n      this.writeZLibHeader();\n    }\n  }\n  Object.defineProperty(CompressedStreamWriter.prototype, \"compressedData\", {\n    /**\n     * get compressed data\n     */\n    get: function () {\n      return this.stream;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CompressedStreamWriter.prototype, \"getCompressedString\", {\n    get: function () {\n      var compressedString = '';\n      if (this.stream !== undefined) {\n        for (var i = 0; i < this.stream.length; i++) {\n          compressedString += String.fromCharCode.apply(null, this.stream[i]);\n        }\n      }\n      return compressedString;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Compresses data and writes it to the stream.\n   * @param {Uint8Array} data - data to compress\n   * @param {number} offset - offset in data\n   * @param {number} length - length of the data\n   * @returns {void}\n   */\n  CompressedStreamWriter.prototype.write = function (data, offset, length) {\n    if (data === undefined || data === null) {\n      throw new Error('ArgumentException: data cannot null or undefined');\n    }\n    var end = offset + length;\n    if (0 > offset || offset > end || end > data.length) {\n      throw new Error('ArgumentOutOfRangeException: Offset or length is incorrect');\n    }\n    if (typeof data === 'string') {\n      var encode = new Encoding(false);\n      encode.type = 'Utf8';\n      data = new Uint8Array(encode.getBytes(data, 0, data.length));\n      end = offset + data.length;\n    }\n    this.inputBuffer = data;\n    this.inputOffset = offset;\n    this.inputEnd = end;\n    if (!this.noWrap) {\n      this.checkSum = ChecksumCalculator.checksumUpdate(this.checkSum, this.inputBuffer, this.inputOffset, end);\n    }\n    while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0)) {\n      this.pendingBufferFlush();\n      this.compressData(false);\n    }\n  };\n  /**\n   * write ZLib header to the compressed data\n   * @return {void}\n   */\n  CompressedStreamWriter.prototype.writeZLibHeader = function () {\n    /* Initialize header.*/\n    var headerDate = 8 + (7 << 4) << 8;\n    /* Save compression level.*/\n    headerDate |= (5 >> 2 & 3) << 6;\n    /* Align header.*/\n    headerDate += 31 - headerDate % 31;\n    /* Write header to stream.*/\n    this.pendingBufferWriteShortBytes(headerDate);\n  };\n  /**\n   *  Write Most Significant Bytes in to stream\n   * @param {number} s - check sum value\n   */\n  CompressedStreamWriter.prototype.pendingBufferWriteShortBytes = function (s) {\n    this.pendingBuffer[this.pendingBufLength++] = s >> 8;\n    this.pendingBuffer[this.pendingBufLength++] = s;\n  };\n  CompressedStreamWriter.prototype.compressData = function (finish) {\n    var success;\n    do {\n      this.fillWindow();\n      var canFlush = finish && this.inputEnd === this.inputOffset;\n      success = this.compressSlow(canFlush, finish);\n    } while (this.pendingBufLength === 0 && success);\n    return success;\n  };\n  CompressedStreamWriter.prototype.compressSlow = function (flush, finish) {\n    if (this.lookAhead < 262 && !flush) {\n      return false;\n    }\n    while (this.lookAhead >= 262 || flush) {\n      if (this.lookAhead === 0) {\n        return this.lookAheadCompleted(finish);\n      }\n      if (this.stringStart >= 2 * this.windowSize - 262) {\n        this.slideWindow();\n      }\n      var prevMatch = this.matchStart;\n      var prevLen = this.matchLength;\n      if (this.lookAhead >= 3) {\n        this.discardMatch();\n      }\n      if (prevLen >= 3 && this.matchLength <= prevLen) {\n        prevLen = this.matchPreviousBest(prevMatch, prevLen);\n      } else {\n        this.matchPreviousAvailable();\n      }\n      if (this.bufferPosition >= 1 << 14) {\n        return this.huffmanIsFull(finish);\n      }\n    }\n    return true;\n  };\n  CompressedStreamWriter.prototype.discardMatch = function () {\n    var hashHead = this.insertString();\n    if (hashHead !== 0 && this.stringStart - hashHead <= this.maxDist && this.findLongestMatch(hashHead)) {\n      if (this.matchLength <= 5 && this.matchLength === 3 && this.stringStart - this.matchStart > 4096) {\n        this.matchLength = 3 - 1;\n      }\n    }\n  };\n  CompressedStreamWriter.prototype.matchPreviousAvailable = function () {\n    if (this.matchPrevAvail) {\n      this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n    }\n    this.matchPrevAvail = true;\n    this.stringStart++;\n    this.lookAhead--;\n  };\n  CompressedStreamWriter.prototype.matchPreviousBest = function (prevMatch, prevLen) {\n    this.huffmanTallyDist(this.stringStart - 1 - prevMatch, prevLen);\n    prevLen -= 2;\n    do {\n      this.stringStart++;\n      this.lookAhead--;\n      if (this.lookAhead >= 3) {\n        this.insertString();\n      }\n    } while (--prevLen > 0);\n    this.stringStart++;\n    this.lookAhead--;\n    this.matchPrevAvail = false;\n    this.matchLength = 3 - 1;\n    return prevLen;\n  };\n  CompressedStreamWriter.prototype.lookAheadCompleted = function (finish) {\n    if (this.matchPrevAvail) {\n      this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n    }\n    this.matchPrevAvail = false;\n    this.huffmanFlushBlock(this.dataWindow, this.blockStart, this.stringStart - this.blockStart, finish);\n    this.blockStart = this.stringStart;\n    return false;\n  };\n  CompressedStreamWriter.prototype.huffmanIsFull = function (finish) {\n    var len = this.stringStart - this.blockStart;\n    if (this.matchPrevAvail) {\n      len--;\n    }\n    var lastBlock = finish && this.lookAhead === 0 && !this.matchPrevAvail;\n    this.huffmanFlushBlock(this.dataWindow, this.blockStart, len, lastBlock);\n    this.blockStart += len;\n    return !lastBlock;\n  };\n  CompressedStreamWriter.prototype.fillWindow = function () {\n    if (this.stringStart >= this.windowSize + this.maxDist) {\n      this.slideWindow();\n    }\n    while (this.lookAhead < 262 && this.inputOffset < this.inputEnd) {\n      var more = 2 * this.windowSize - this.lookAhead - this.stringStart;\n      if (more > this.inputEnd - this.inputOffset) {\n        more = this.inputEnd - this.inputOffset;\n      }\n      this.dataWindow.set(this.inputBuffer.subarray(this.inputOffset, this.inputOffset + more), this.stringStart + this.lookAhead);\n      this.inputOffset += more;\n      this.totalBytesIn += more;\n      this.lookAhead += more;\n    }\n    if (this.lookAhead >= 3) {\n      this.updateHash();\n    }\n  };\n  CompressedStreamWriter.prototype.slideWindow = function () {\n    this.dataWindow.set(this.dataWindow.subarray(this.windowSize, this.windowSize + this.windowSize), 0);\n    this.matchStart -= this.windowSize;\n    this.stringStart -= this.windowSize;\n    this.blockStart -= this.windowSize;\n    for (var i = 0; i < this.hashSize; ++i) {\n      var m = this.hashHead[i] & 0xffff;\n      this.hashHead[i] = m >= this.windowSize ? m - this.windowSize : 0;\n    }\n    for (var i = 0; i < this.windowSize; i++) {\n      var m = this.hashPrevious[i] & 0xffff;\n      this.hashPrevious[i] = m >= this.windowSize ? m - this.windowSize : 0;\n    }\n  };\n  CompressedStreamWriter.prototype.insertString = function () {\n    var match;\n    var hash = (this.currentHash << this.hashShift ^ this.dataWindow[this.stringStart + (3 - 1)]) & this.hashMask;\n    this.hashPrevious[this.stringStart & this.windowMask] = match = this.hashHead[hash];\n    this.hashHead[hash] = this.stringStart;\n    this.currentHash = hash;\n    return match & 0xffff;\n  };\n  CompressedStreamWriter.prototype.findLongestMatch = function (curMatch) {\n    var chainLen = 4096;\n    var niceLen = 258;\n    var scan = this.stringStart;\n    var match;\n    var bestEnd = this.stringStart + this.matchLength;\n    var bestLength = Math.max(this.matchLength, 3 - 1);\n    var limit = Math.max(this.stringStart - this.maxDist, 0);\n    var stringEnd = this.stringStart + 258 - 1;\n    var scanEnd1 = this.dataWindow[bestEnd - 1];\n    var scanEnd = this.dataWindow[bestEnd];\n    var data = this.dataWindow;\n    if (bestLength >= 32) {\n      chainLen >>= 2;\n    }\n    if (niceLen > this.lookAhead) {\n      niceLen = this.lookAhead;\n    }\n    do {\n      if (data[curMatch + bestLength] !== scanEnd || data[curMatch + bestLength - 1] !== scanEnd1 || data[curMatch] !== data[scan] || data[curMatch + 1] !== data[scan + 1]) {\n        continue;\n      }\n      match = curMatch + 2;\n      scan += 2;\n      /* tslint:disable */\n      while (data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && scan < stringEnd) {\n        /* tslint:disable */\n      }\n      if (scan > bestEnd) {\n        this.matchStart = curMatch;\n        bestEnd = scan;\n        bestLength = scan - this.stringStart;\n        if (bestLength >= niceLen) {\n          break;\n        }\n        scanEnd1 = data[bestEnd - 1];\n        scanEnd = data[bestEnd];\n      }\n      scan = this.stringStart;\n    } while ((curMatch = this.hashPrevious[curMatch & this.windowMask] & 0xffff) > limit && --chainLen !== 0);\n    this.matchLength = Math.min(bestLength, this.lookAhead);\n    return this.matchLength >= 3;\n  };\n  CompressedStreamWriter.prototype.updateHash = function () {\n    this.currentHash = this.dataWindow[this.stringStart] << this.hashShift ^ this.dataWindow[this.stringStart + 1];\n  };\n  CompressedStreamWriter.prototype.huffmanTallyLit = function (literal) {\n    this.arrDistances[this.bufferPosition] = 0;\n    this.arrLiterals[this.bufferPosition++] = literal;\n    this.treeLiteral.codeFrequencies[literal]++;\n    return this.bufferPosition >= 1 << 14;\n  };\n  CompressedStreamWriter.prototype.huffmanTallyDist = function (dist, len) {\n    this.arrDistances[this.bufferPosition] = dist;\n    this.arrLiterals[this.bufferPosition++] = len - 3;\n    var lc = this.huffmanLengthCode(len - 3);\n    this.treeLiteral.codeFrequencies[lc]++;\n    if (lc >= 265 && lc < 285) {\n      this.extraBits += Math.floor((lc - 261) / 4);\n    }\n    var dc = this.huffmanDistanceCode(dist - 1);\n    this.treeDistances.codeFrequencies[dc]++;\n    if (dc >= 4) {\n      this.extraBits += Math.floor(dc / 2 - 1);\n    }\n    return this.bufferPosition >= 1 << 14;\n  };\n  CompressedStreamWriter.prototype.huffmanFlushBlock = function (stored, storedOffset, storedLength, lastBlock) {\n    this.treeLiteral.codeFrequencies[256]++;\n    this.treeLiteral.buildTree();\n    this.treeDistances.buildTree();\n    this.treeLiteral.calculateBLFreq(this.treeCodeLengths);\n    this.treeDistances.calculateBLFreq(this.treeCodeLengths);\n    this.treeCodeLengths.buildTree();\n    var blTreeCodes = 4;\n    for (var i = 18; i > blTreeCodes; i--) {\n      if (this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[i]] > 0) {\n        blTreeCodes = i + 1;\n      }\n    }\n    var opt_len = 14 + blTreeCodes * 3 + this.treeCodeLengths.getEncodedLength() + this.treeLiteral.getEncodedLength() + this.treeDistances.getEncodedLength() + this.extraBits;\n    var static_len = this.extraBits;\n    for (var i = 0; i < 286; i++) {\n      static_len += this.treeLiteral.codeFrequencies[i] * ARR_LITERAL_LENGTHS[i];\n    }\n    for (var i = 0; i < 30; i++) {\n      static_len += this.treeDistances.codeFrequencies[i] * ARR_DISTANCE_LENGTHS[i];\n    }\n    if (opt_len >= static_len) {\n      // Force static trees.\n      opt_len = static_len;\n    }\n    if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {\n      this.huffmanFlushStoredBlock(stored, storedOffset, storedLength, lastBlock);\n    } else if (opt_len == static_len) {\n      // Encode with static tree.\n      this.pendingBufferWriteBits((1 << 1) + (lastBlock ? 1 : 0), 3);\n      this.treeLiteral.setStaticCodes(ARR_LITERAL_CODES, ARR_LITERAL_LENGTHS);\n      this.treeDistances.setStaticCodes(ARR_DISTANCE_CODES, ARR_DISTANCE_LENGTHS);\n      this.huffmanCompressBlock();\n      this.huffmanReset();\n    } else {\n      this.pendingBufferWriteBits((2 << 1) + (lastBlock ? 1 : 0), 3);\n      this.huffmanSendAllTrees(blTreeCodes);\n      this.huffmanCompressBlock();\n      this.huffmanReset();\n    }\n  };\n  CompressedStreamWriter.prototype.huffmanFlushStoredBlock = function (stored, storedOffset, storedLength, lastBlock) {\n    this.pendingBufferWriteBits((0 << 1) + (lastBlock ? 1 : 0), 3);\n    this.pendingBufferAlignToByte();\n    this.pendingBufferWriteShort(storedLength);\n    this.pendingBufferWriteShort(~storedLength);\n    this.pendingBufferWriteByteBlock(stored, storedOffset, storedLength);\n    this.huffmanReset();\n  };\n  CompressedStreamWriter.prototype.huffmanLengthCode = function (len) {\n    if (len === 255) {\n      return 285;\n    }\n    var code = 257;\n    while (len >= 8) {\n      code += 4;\n      len >>= 1;\n    }\n    return code + len;\n  };\n  CompressedStreamWriter.prototype.huffmanDistanceCode = function (distance) {\n    var code = 0;\n    while (distance >= 4) {\n      code += 2;\n      distance >>= 1;\n    }\n    return code + distance;\n  };\n  CompressedStreamWriter.prototype.huffmanSendAllTrees = function (blTreeCodes) {\n    this.treeCodeLengths.buildCodes();\n    this.treeLiteral.buildCodes();\n    this.treeDistances.buildCodes();\n    this.pendingBufferWriteBits(this.treeLiteral.treeLength - 257, 5);\n    this.pendingBufferWriteBits(this.treeDistances.treeLength - 1, 5);\n    this.pendingBufferWriteBits(blTreeCodes - 4, 4);\n    for (var rank = 0; rank < blTreeCodes; rank++) {\n      this.pendingBufferWriteBits(this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[rank]], 3);\n    }\n    this.treeLiteral.writeTree(this.treeCodeLengths);\n    this.treeDistances.writeTree(this.treeCodeLengths);\n  };\n  CompressedStreamWriter.prototype.huffmanReset = function () {\n    this.bufferPosition = 0;\n    this.extraBits = 0;\n    this.treeLiteral.reset();\n    this.treeDistances.reset();\n    this.treeCodeLengths.reset();\n  };\n  CompressedStreamWriter.prototype.huffmanCompressBlock = function () {\n    for (var i = 0; i < this.bufferPosition; i++) {\n      var literalLen = this.arrLiterals[i] & 255;\n      var dist = this.arrDistances[i];\n      if (dist-- !== 0) {\n        var lc = this.huffmanLengthCode(literalLen);\n        this.treeLiteral.writeCodeToStream(lc);\n        var bits = Math.floor((lc - 261) / 4);\n        if (bits > 0 && bits <= 5) {\n          this.pendingBufferWriteBits(literalLen & (1 << bits) - 1, bits);\n        }\n        var dc = this.huffmanDistanceCode(dist);\n        this.treeDistances.writeCodeToStream(dc);\n        bits = Math.floor(dc / 2 - 1);\n        if (bits > 0) {\n          this.pendingBufferWriteBits(dist & (1 << bits) - 1, bits);\n        }\n      } else {\n        this.treeLiteral.writeCodeToStream(literalLen);\n      }\n    }\n    this.treeLiteral.writeCodeToStream(256);\n  };\n  /**\n   * write bits in to internal buffer\n   * @param {number} b - source of bits\n   * @param {number} count - count of bits to write\n   */\n  CompressedStreamWriter.prototype.pendingBufferWriteBits = function (b, count) {\n    var uint = new Uint32Array(1);\n    uint[0] = this.pendingBufCache | b << this.pendingBufBitsInCache;\n    this.pendingBufCache = uint[0];\n    this.pendingBufBitsInCache += count;\n    this.pendingBufferFlushBits();\n  };\n  CompressedStreamWriter.prototype.pendingBufferFlush = function (isClose) {\n    this.pendingBufferFlushBits();\n    if (this.pendingBufLength > 0) {\n      var array = new Uint8Array(this.pendingBufLength);\n      array.set(this.pendingBuffer.subarray(0, this.pendingBufLength), 0);\n      this.stream.push(array);\n    }\n    this.pendingBufLength = 0;\n  };\n  CompressedStreamWriter.prototype.pendingBufferFlushBits = function () {\n    var result = 0;\n    while (this.pendingBufBitsInCache >= 8 && this.pendingBufLength < 1 << 16) {\n      this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n      this.pendingBufCache >>= 8;\n      this.pendingBufBitsInCache -= 8;\n      result++;\n    }\n    return result;\n  };\n  CompressedStreamWriter.prototype.pendingBufferWriteByteBlock = function (data, offset, length) {\n    var array = data.subarray(offset, offset + length);\n    this.pendingBuffer.set(array, this.pendingBufLength);\n    this.pendingBufLength += length;\n  };\n  CompressedStreamWriter.prototype.pendingBufferWriteShort = function (s) {\n    this.pendingBuffer[this.pendingBufLength++] = s;\n    this.pendingBuffer[this.pendingBufLength++] = s >> 8;\n  };\n  CompressedStreamWriter.prototype.pendingBufferAlignToByte = function () {\n    if (this.pendingBufBitsInCache > 0) {\n      this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n    }\n    this.pendingBufCache = 0;\n    this.pendingBufBitsInCache = 0;\n  };\n  /**\n   * Huffman Tree literal calculation\n   * @private\n   */\n  CompressedStreamWriter.initHuffmanTree = function () {\n    var i = 0;\n    while (i < 144) {\n      ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x030 + i << 8);\n      ARR_LITERAL_LENGTHS[i++] = 8;\n    }\n    while (i < 256) {\n      ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x190 - 144 + i << 7);\n      ARR_LITERAL_LENGTHS[i++] = 9;\n    }\n    while (i < 280) {\n      ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x000 - 256 + i << 9);\n      ARR_LITERAL_LENGTHS[i++] = 7;\n    }\n    while (i < 286) {\n      ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x0c0 - 280 + i << 8);\n      ARR_LITERAL_LENGTHS[i++] = 8;\n    }\n    for (i = 0; i < 30; i++) {\n      ARR_DISTANCE_CODES[i] = CompressorHuffmanTree.bitReverse(i << 11);\n      ARR_DISTANCE_LENGTHS[i] = 5;\n    }\n  };\n  /**\n   * close the stream and write all pending buffer in to stream\n   * @returns {void}\n   */\n  CompressedStreamWriter.prototype.close = function () {\n    do {\n      this.pendingBufferFlush(true);\n      if (!this.compressData(true)) {\n        this.pendingBufferFlush(true);\n        this.pendingBufferAlignToByte();\n        if (!this.noWrap) {\n          this.pendingBufferWriteShortBytes(this.checkSum >> 16);\n          this.pendingBufferWriteShortBytes(this.checkSum & 0xffff);\n        }\n        this.pendingBufferFlush(true);\n      }\n    } while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0));\n  };\n  /**\n   * release allocated un-managed resource\n   * @returns {void}\n   */\n  CompressedStreamWriter.prototype.destroy = function () {\n    this.stream = [];\n    this.stream = undefined;\n    this.pendingBuffer = undefined;\n    this.treeLiteral = undefined;\n    this.treeDistances = undefined;\n    this.treeCodeLengths = undefined;\n    this.arrLiterals = undefined;\n    this.arrDistances = undefined;\n    this.hashHead = undefined;\n    this.hashPrevious = undefined;\n    this.dataWindow = undefined;\n    this.inputBuffer = undefined;\n    this.pendingBufLength = undefined;\n    this.pendingBufCache = undefined;\n    this.pendingBufBitsInCache = undefined;\n    this.bufferPosition = undefined;\n    this.extraBits = undefined;\n    this.currentHash = undefined;\n    this.matchStart = undefined;\n    this.matchLength = undefined;\n    this.matchPrevAvail = undefined;\n    this.blockStart = undefined;\n    this.stringStart = undefined;\n    this.lookAhead = undefined;\n    this.totalBytesIn = undefined;\n    this.inputOffset = undefined;\n    this.inputEnd = undefined;\n    this.windowSize = undefined;\n    this.windowMask = undefined;\n    this.hashSize = undefined;\n    this.hashMask = undefined;\n    this.hashShift = undefined;\n    this.maxDist = undefined;\n    this.checkSum = undefined;\n    this.noWrap = undefined;\n  };\n  CompressedStreamWriter.isHuffmanTreeInitiated = false;\n  return CompressedStreamWriter;\n}();\nexport { CompressedStreamWriter };\n/**\n * represent the Huffman Tree\n */\nvar CompressorHuffmanTree = /** @class */function () {\n  /**\n   * Create new Huffman Tree\n   * @param {CompressedStreamWriter} writer instance\n   * @param {number} elementCount - element count\n   * @param {number} minCodes - minimum count\n   * @param {number} maxLength - maximum count\n   */\n  function CompressorHuffmanTree(writer, elementCount, minCodes, maxLength) {\n    this.writer = writer;\n    this.codeMinCount = minCodes;\n    this.maxLength = maxLength;\n    this.codeFrequency = new Uint16Array(elementCount);\n    this.lengthCount = new Int32Array(maxLength);\n  }\n  Object.defineProperty(CompressorHuffmanTree.prototype, \"treeLength\", {\n    get: function () {\n      return this.codeCount;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CompressorHuffmanTree.prototype, \"codeLengths\", {\n    get: function () {\n      return this.codeLength;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CompressorHuffmanTree.prototype, \"codeFrequencies\", {\n    get: function () {\n      return this.codeFrequency;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  CompressorHuffmanTree.prototype.setStaticCodes = function (codes, lengths) {\n    var temp = new Int16Array(codes.length);\n    temp.set(codes, 0);\n    this.codes = temp;\n    var lengthTemp = new Uint8Array(lengths.length);\n    lengthTemp.set(lengths, 0);\n    this.codeLength = lengthTemp;\n  };\n  /**\n   * reset all code data in tree\n   * @returns {void}\n   */\n  CompressorHuffmanTree.prototype.reset = function () {\n    for (var i = 0; i < this.codeFrequency.length; i++) {\n      this.codeFrequency[i] = 0;\n    }\n    this.codes = undefined;\n    this.codeLength = undefined;\n  };\n  /**\n   * write code to the compressor output stream\n   * @param {number} code - code to be written\n   * @returns {void}\n   */\n  CompressorHuffmanTree.prototype.writeCodeToStream = function (code) {\n    this.writer.pendingBufferWriteBits(this.codes[code] & 0xffff, this.codeLength[code]);\n  };\n  /**\n   * calculate code from their frequencies\n   * @returns {void}\n   */\n  CompressorHuffmanTree.prototype.buildCodes = function () {\n    var nextCode = new Int32Array(this.maxLength);\n    this.codes = new Int16Array(this.codeCount);\n    var code = 0;\n    for (var bitsCount = 0; bitsCount < this.maxLength; bitsCount++) {\n      nextCode[bitsCount] = code;\n      code += this.lengthCount[bitsCount] << 15 - bitsCount;\n    }\n    for (var i = 0; i < this.codeCount; i++) {\n      var bits = this.codeLength[i];\n      if (bits > 0) {\n        this.codes[i] = CompressorHuffmanTree.bitReverse(nextCode[bits - 1]);\n        nextCode[bits - 1] += 1 << 16 - bits;\n      }\n    }\n  };\n  CompressorHuffmanTree.bitReverse = function (value) {\n    return CompressorHuffmanTree.reverseBits[value & 15] << 12 | CompressorHuffmanTree.reverseBits[value >> 4 & 15] << 8 | CompressorHuffmanTree.reverseBits[value >> 8 & 15] << 4 | CompressorHuffmanTree.reverseBits[value >> 12];\n  };\n  /**\n   * calculate length of compressed data\n   * @returns {number}\n   */\n  CompressorHuffmanTree.prototype.getEncodedLength = function () {\n    var len = 0;\n    for (var i = 0; i < this.codeFrequency.length; i++) {\n      len += this.codeFrequency[i] * this.codeLength[i];\n    }\n    return len;\n  };\n  /**\n   * calculate code frequencies\n   * @param {CompressorHuffmanTree} blTree\n   * @returns {void}\n   */\n  CompressorHuffmanTree.prototype.calculateBLFreq = function (blTree) {\n    var maxCount;\n    var minCount;\n    var count;\n    var curLen = -1;\n    var i = 0;\n    while (i < this.codeCount) {\n      count = 1;\n      var nextLen = this.codeLength[i];\n      if (nextLen === 0) {\n        maxCount = 138;\n        minCount = 3;\n      } else {\n        maxCount = 6;\n        minCount = 3;\n        if (curLen !== nextLen) {\n          blTree.codeFrequency[nextLen]++;\n          count = 0;\n        }\n      }\n      curLen = nextLen;\n      i++;\n      while (i < this.codeCount && curLen === this.codeLength[i]) {\n        i++;\n        if (++count >= maxCount) {\n          break;\n        }\n      }\n      if (count < minCount) {\n        blTree.codeFrequency[curLen] += count;\n      } else if (curLen !== 0) {\n        blTree.codeFrequency[16]++;\n      } else if (count <= 10) {\n        blTree.codeFrequency[17]++;\n      } else {\n        blTree.codeFrequency[18]++;\n      }\n    }\n  };\n  /**\n   * @param {CompressorHuffmanTree} blTree - write tree to output stream\n   * @returns {void}\n   */\n  CompressorHuffmanTree.prototype.writeTree = function (blTree) {\n    var maxRepeatCount;\n    var minRepeatCount;\n    var currentRepeatCount;\n    var currentCodeLength = -1;\n    var i = 0;\n    while (i < this.codeCount) {\n      currentRepeatCount = 1;\n      var nextLen = this.codeLength[i];\n      if (nextLen === 0) {\n        maxRepeatCount = 138;\n        minRepeatCount = 3;\n      } else {\n        maxRepeatCount = 6;\n        minRepeatCount = 3;\n        if (currentCodeLength !== nextLen) {\n          blTree.writeCodeToStream(nextLen);\n          currentRepeatCount = 0;\n        }\n      }\n      currentCodeLength = nextLen;\n      i++;\n      while (i < this.codeCount && currentCodeLength === this.codeLength[i]) {\n        i++;\n        if (++currentRepeatCount >= maxRepeatCount) {\n          break;\n        }\n      }\n      if (currentRepeatCount < minRepeatCount) {\n        while (currentRepeatCount-- > 0) {\n          blTree.writeCodeToStream(currentCodeLength);\n        }\n      } else if (currentCodeLength !== 0) {\n        blTree.writeCodeToStream(16);\n        this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 2);\n      } else if (currentRepeatCount <= 10) {\n        blTree.writeCodeToStream(17);\n        this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 3);\n      } else {\n        blTree.writeCodeToStream(18);\n        this.writer.pendingBufferWriteBits(currentRepeatCount - 11, 7);\n      }\n    }\n  };\n  /**\n   * Build huffman tree\n   * @returns {void}\n   */\n  CompressorHuffmanTree.prototype.buildTree = function () {\n    var codesCount = this.codeFrequency.length;\n    var arrTree = new Int32Array(codesCount);\n    var treeLength = 0;\n    var maxCount = 0;\n    for (var n = 0; n < codesCount; n++) {\n      var freq = this.codeFrequency[n];\n      if (freq !== 0) {\n        var pos = treeLength++;\n        var pPos = 0;\n        while (pos > 0 && this.codeFrequency[arrTree[pPos = Math.floor((pos - 1) / 2)]] > freq) {\n          arrTree[pos] = arrTree[pPos];\n          pos = pPos;\n        }\n        arrTree[pos] = n;\n        maxCount = n;\n      }\n    }\n    while (treeLength < 2) {\n      arrTree[treeLength++] = maxCount < 2 ? ++maxCount : 0;\n    }\n    this.codeCount = Math.max(maxCount + 1, this.codeMinCount);\n    var leafsCount = treeLength;\n    var nodesCount = leafsCount;\n    var child = new Int32Array(4 * treeLength - 2);\n    var values = new Int32Array(2 * treeLength - 1);\n    for (var i = 0; i < treeLength; i++) {\n      var node = arrTree[i];\n      var iIndex = 2 * i;\n      child[iIndex] = node;\n      child[iIndex + 1] = -1;\n      values[i] = this.codeFrequency[node] << 8;\n      arrTree[i] = i;\n    }\n    this.constructHuffmanTree(arrTree, treeLength, values, nodesCount, child);\n    this.buildLength(child);\n  };\n  CompressorHuffmanTree.prototype.constructHuffmanTree = function (arrTree, treeLength, values, nodesCount, child) {\n    do {\n      var first = arrTree[0];\n      var last = arrTree[--treeLength];\n      var lastVal = values[last];\n      var pPos = 0;\n      var path = 1;\n      while (path < treeLength) {\n        if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n          path++;\n        }\n        arrTree[pPos] = arrTree[path];\n        pPos = path;\n        path = pPos * 2 + 1;\n      }\n      while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n        arrTree[path] = arrTree[pPos];\n      }\n      arrTree[path] = last;\n      var second = arrTree[0];\n      last = nodesCount++;\n      child[2 * last] = first;\n      child[2 * last + 1] = second;\n      var minDepth = Math.min(values[first] & 0xff, values[second] & 0xff);\n      values[last] = lastVal = values[first] + values[second] - minDepth + 1;\n      pPos = 0;\n      path = 1;\n      /* tslint:disable */\n      while (path < treeLength) {\n        if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n          path++;\n        }\n        arrTree[pPos] = arrTree[path];\n        pPos = path;\n        path = pPos * 2 + 1;\n      } /* tslint:disable */\n      while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n        arrTree[path] = arrTree[pPos];\n      }\n      arrTree[path] = last;\n    } while (treeLength > 1);\n  };\n  CompressorHuffmanTree.prototype.buildLength = function (child) {\n    this.codeLength = new Uint8Array(this.codeFrequency.length);\n    var numNodes = Math.floor(child.length / 2);\n    var numLeafs = Math.floor((numNodes + 1) / 2);\n    var overflow = 0;\n    for (var i = 0; i < this.maxLength; i++) {\n      this.lengthCount[i] = 0;\n    }\n    overflow = this.calculateOptimalCodeLength(child, overflow, numNodes);\n    if (overflow === 0) {\n      return;\n    }\n    var iIncreasableLength = this.maxLength - 1;\n    do {\n      while (this.lengthCount[--iIncreasableLength] === 0) {\n        /* tslint:disable */\n      }\n      do {\n        this.lengthCount[iIncreasableLength]--;\n        this.lengthCount[++iIncreasableLength]++;\n        overflow -= 1 << this.maxLength - 1 - iIncreasableLength;\n      } while (overflow > 0 && iIncreasableLength < this.maxLength - 1);\n    } while (overflow > 0);\n    this.recreateTree(child, overflow, numLeafs);\n  };\n  CompressorHuffmanTree.prototype.recreateTree = function (child, overflow, numLeafs) {\n    this.lengthCount[this.maxLength - 1] += overflow;\n    this.lengthCount[this.maxLength - 2] -= overflow;\n    var nodePtr = 2 * numLeafs;\n    for (var bits = this.maxLength; bits !== 0; bits--) {\n      var n = this.lengthCount[bits - 1];\n      while (n > 0) {\n        var childPtr = 2 * child[nodePtr++];\n        if (child[childPtr + 1] === -1) {\n          this.codeLength[child[childPtr]] = bits;\n          n--;\n        }\n      }\n    }\n  };\n  CompressorHuffmanTree.prototype.calculateOptimalCodeLength = function (child, overflow, numNodes) {\n    var lengths = new Int32Array(numNodes);\n    lengths[numNodes - 1] = 0;\n    for (var i = numNodes - 1; i >= 0; i--) {\n      var childIndex = 2 * i + 1;\n      if (child[childIndex] !== -1) {\n        var bitLength = lengths[i] + 1;\n        if (bitLength > this.maxLength) {\n          bitLength = this.maxLength;\n          overflow++;\n        }\n        lengths[child[childIndex - 1]] = lengths[child[childIndex]] = bitLength;\n      } else {\n        var bitLength = lengths[i];\n        this.lengthCount[bitLength - 1]++;\n        this.codeLength[child[childIndex - 1]] = lengths[i];\n      }\n    }\n    return overflow;\n  };\n  CompressorHuffmanTree.reverseBits = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];\n  CompressorHuffmanTree.huffCodeLengthOrders = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n  return CompressorHuffmanTree;\n}();\nexport { CompressorHuffmanTree };\n/**\n * Checksum calculator, based on Adler32 algorithm.\n */\nvar ChecksumCalculator = /** @class */function () {\n  function ChecksumCalculator() {}\n  /**\n   * Updates checksum by calculating checksum of the\n   * given buffer and adding it to current value.\n   * @param {number} checksum - current checksum.\n   * @param {Uint8Array} buffer - data byte array.\n   * @param {number} offset - offset in the buffer.\n   * @param {number} length - length of data to be used from the stream.\n   * @returns {number}\n   */\n  ChecksumCalculator.checksumUpdate = function (checksum, buffer, offset, length) {\n    var uint = new Uint32Array(1);\n    uint[0] = checksum;\n    var checksum_uint = uint[0];\n    var s1 = uint[0] = checksum_uint & 65535;\n    var s2 = uint[0] = checksum_uint >> ChecksumCalculator.checkSumBitOffset;\n    while (length > 0) {\n      var steps = Math.min(length, ChecksumCalculator.checksumIterationCount);\n      length -= steps;\n      while (--steps >= 0) {\n        s1 = s1 + (uint[0] = buffer[offset++] & 255);\n        s2 = s2 + s1;\n      }\n      s1 %= ChecksumCalculator.checksumBase;\n      s2 %= ChecksumCalculator.checksumBase;\n    }\n    checksum_uint = s2 << ChecksumCalculator.checkSumBitOffset | s1;\n    return checksum_uint;\n  };\n  ChecksumCalculator.checkSumBitOffset = 16;\n  ChecksumCalculator.checksumBase = 65521;\n  ChecksumCalculator.checksumIterationCount = 3800;\n  return ChecksumCalculator;\n}();\nexport { ChecksumCalculator };","map":{"version":3,"names":["Encoding","ARR_LITERAL_CODES","Int16Array","ARR_LITERAL_LENGTHS","Uint8Array","ARR_DISTANCE_CODES","ARR_DISTANCE_LENGTHS","CompressedStreamWriter","noWrap","pendingBuffer","pendingBufLength","pendingBufCache","pendingBufBitsInCache","bufferPosition","extraBits","currentHash","matchStart","matchLength","matchPrevAvail","blockStart","stringStart","lookAhead","totalBytesIn","inputOffset","inputEnd","windowSize","windowMask","hashSize","hashMask","hashShift","Math","floor","maxDist","checkSum","isHuffmanTreeInitiated","initHuffmanTree","treeLiteral","CompressorHuffmanTree","treeDistances","treeCodeLengths","arrDistances","Uint16Array","arrLiterals","stream","dataWindow","hashHead","hashPrevious","writeZLibHeader","Object","defineProperty","prototype","get","enumerable","configurable","compressedString","undefined","i","length","String","fromCharCode","apply","write","data","offset","Error","end","encode","type","getBytes","inputBuffer","ChecksumCalculator","checksumUpdate","pendingBufferFlush","compressData","headerDate","pendingBufferWriteShortBytes","s","finish","success","fillWindow","canFlush","compressSlow","flush","lookAheadCompleted","slideWindow","prevMatch","prevLen","discardMatch","matchPreviousBest","matchPreviousAvailable","huffmanIsFull","insertString","findLongestMatch","huffmanTallyLit","huffmanTallyDist","huffmanFlushBlock","len","lastBlock","more","set","subarray","updateHash","m","match","hash","curMatch","chainLen","niceLen","scan","bestEnd","bestLength","max","limit","stringEnd","scanEnd1","scanEnd","min","literal","codeFrequencies","dist","lc","huffmanLengthCode","dc","huffmanDistanceCode","stored","storedOffset","storedLength","buildTree","calculateBLFreq","blTreeCodes","codeLengths","huffCodeLengthOrders","opt_len","getEncodedLength","static_len","huffmanFlushStoredBlock","pendingBufferWriteBits","setStaticCodes","huffmanCompressBlock","huffmanReset","huffmanSendAllTrees","pendingBufferAlignToByte","pendingBufferWriteShort","pendingBufferWriteByteBlock","code","distance","buildCodes","treeLength","rank","writeTree","reset","literalLen","writeCodeToStream","bits","b","count","uint","Uint32Array","pendingBufferFlushBits","isClose","array","push","result","bitReverse","close","destroy","writer","elementCount","minCodes","maxLength","codeMinCount","codeFrequency","lengthCount","Int32Array","codeCount","codeLength","codes","lengths","temp","lengthTemp","nextCode","bitsCount","value","reverseBits","blTree","maxCount","minCount","curLen","nextLen","maxRepeatCount","minRepeatCount","currentRepeatCount","currentCodeLength","codesCount","arrTree","n","freq","pos","pPos","leafsCount","nodesCount","child","values","node","iIndex","constructHuffmanTree","buildLength","first","last","lastVal","path","second","minDepth","numNodes","numLeafs","overflow","calculateOptimalCodeLength","iIncreasableLength","recreateTree","nodePtr","childPtr","childIndex","bitLength","checksum","buffer","checksum_uint","s1","s2","checkSumBitOffset","steps","checksumIterationCount","checksumBase"],"sources":["/Users/macbookpro16/Desktop/cs222/client/node_modules/@syncfusion/ej2-compression/src/compression-writer.js"],"sourcesContent":["import { Encoding } from '@syncfusion/ej2-file-utils';\n/**\n * array literal codes\n */\nvar ARR_LITERAL_CODES = new Int16Array(286);\nvar ARR_LITERAL_LENGTHS = new Uint8Array(286);\nvar ARR_DISTANCE_CODES = new Int16Array(30);\nvar ARR_DISTANCE_LENGTHS = new Uint8Array(30);\n/**\n * represent compression stream writer\n * ```typescript\n * let compressedWriter = new CompressedStreamWriter();\n * let text: string = 'Hello world!!!';\n * compressedWriter.write(text, 0, text.length);\n * compressedWriter.close();\n * ```\n */\nvar CompressedStreamWriter = /** @class */ (function () {\n    /**\n     * Initializes compressor and writes ZLib header if needed.\n     * @param {boolean} noWrap - optional if true, ZLib header and checksum will not be written.\n     */\n    function CompressedStreamWriter(noWrap) {\n        this.pendingBuffer = new Uint8Array(1 << 16);\n        this.pendingBufLength = 0;\n        this.pendingBufCache = 0;\n        this.pendingBufBitsInCache = 0;\n        this.bufferPosition = 0;\n        this.extraBits = 0;\n        this.currentHash = 0;\n        this.matchStart = 0;\n        this.matchLength = 0;\n        this.matchPrevAvail = false;\n        this.blockStart = 0;\n        this.stringStart = 0;\n        this.lookAhead = 0;\n        this.totalBytesIn = 0;\n        this.inputOffset = 0;\n        this.inputEnd = 0;\n        this.windowSize = 1 << 15;\n        this.windowMask = this.windowSize - 1;\n        this.hashSize = 1 << 15;\n        this.hashMask = this.hashSize - 1;\n        this.hashShift = Math.floor((15 + 3 - 1) / 3);\n        this.maxDist = this.windowSize - 262;\n        this.checkSum = 1;\n        this.noWrap = false;\n        if (!CompressedStreamWriter.isHuffmanTreeInitiated) {\n            CompressedStreamWriter.initHuffmanTree();\n            CompressedStreamWriter.isHuffmanTreeInitiated = true;\n        }\n        this.treeLiteral = new CompressorHuffmanTree(this, 286, 257, 15);\n        this.treeDistances = new CompressorHuffmanTree(this, 30, 1, 15);\n        this.treeCodeLengths = new CompressorHuffmanTree(this, 19, 4, 7);\n        this.arrDistances = new Uint16Array((1 << 14));\n        this.arrLiterals = new Uint8Array((1 << 14));\n        this.stream = [];\n        this.dataWindow = new Uint8Array(2 * this.windowSize);\n        this.hashHead = new Int16Array(this.hashSize);\n        this.hashPrevious = new Int16Array(this.windowSize);\n        this.blockStart = this.stringStart = 1;\n        this.noWrap = noWrap;\n        if (!noWrap) {\n            this.writeZLibHeader();\n        }\n    }\n    Object.defineProperty(CompressedStreamWriter.prototype, \"compressedData\", {\n        /**\n         * get compressed data\n         */\n        get: function () {\n            return this.stream;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CompressedStreamWriter.prototype, \"getCompressedString\", {\n        get: function () {\n            var compressedString = '';\n            if (this.stream !== undefined) {\n                for (var i = 0; i < this.stream.length; i++) {\n                    compressedString += String.fromCharCode.apply(null, this.stream[i]);\n                }\n            }\n            return compressedString;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Compresses data and writes it to the stream.\n     * @param {Uint8Array} data - data to compress\n     * @param {number} offset - offset in data\n     * @param {number} length - length of the data\n     * @returns {void}\n     */\n    CompressedStreamWriter.prototype.write = function (data, offset, length) {\n        if (data === undefined || data === null) {\n            throw new Error('ArgumentException: data cannot null or undefined');\n        }\n        var end = offset + length;\n        if (0 > offset || offset > end || end > data.length) {\n            throw new Error('ArgumentOutOfRangeException: Offset or length is incorrect');\n        }\n        if (typeof data === 'string') {\n            var encode = new Encoding(false);\n            encode.type = 'Utf8';\n            data = new Uint8Array(encode.getBytes(data, 0, data.length));\n            end = offset + data.length;\n        }\n        this.inputBuffer = data;\n        this.inputOffset = offset;\n        this.inputEnd = end;\n        if (!this.noWrap) {\n            this.checkSum = ChecksumCalculator.checksumUpdate(this.checkSum, this.inputBuffer, this.inputOffset, end);\n        }\n        while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0)) {\n            this.pendingBufferFlush();\n            this.compressData(false);\n        }\n    };\n    /**\n     * write ZLib header to the compressed data\n     * @return {void}\n     */\n    CompressedStreamWriter.prototype.writeZLibHeader = function () {\n        /* Initialize header.*/\n        var headerDate = (8 + (7 << 4)) << 8;\n        /* Save compression level.*/\n        headerDate |= ((5 >> 2) & 3) << 6;\n        /* Align header.*/\n        headerDate += 31 - (headerDate % 31);\n        /* Write header to stream.*/\n        this.pendingBufferWriteShortBytes(headerDate);\n    };\n    /**\n     *  Write Most Significant Bytes in to stream\n     * @param {number} s - check sum value\n     */\n    CompressedStreamWriter.prototype.pendingBufferWriteShortBytes = function (s) {\n        this.pendingBuffer[this.pendingBufLength++] = s >> 8;\n        this.pendingBuffer[this.pendingBufLength++] = s;\n    };\n    CompressedStreamWriter.prototype.compressData = function (finish) {\n        var success;\n        do {\n            this.fillWindow();\n            var canFlush = (finish && this.inputEnd === this.inputOffset);\n            success = this.compressSlow(canFlush, finish);\n        } while (this.pendingBufLength === 0 && success);\n        return success;\n    };\n    CompressedStreamWriter.prototype.compressSlow = function (flush, finish) {\n        if (this.lookAhead < 262 && !flush) {\n            return false;\n        }\n        while (this.lookAhead >= 262 || flush) {\n            if (this.lookAhead === 0) {\n                return this.lookAheadCompleted(finish);\n            }\n            if (this.stringStart >= 2 * this.windowSize - 262) {\n                this.slideWindow();\n            }\n            var prevMatch = this.matchStart;\n            var prevLen = this.matchLength;\n            if (this.lookAhead >= 3) {\n                this.discardMatch();\n            }\n            if (prevLen >= 3 && this.matchLength <= prevLen) {\n                prevLen = this.matchPreviousBest(prevMatch, prevLen);\n            }\n            else {\n                this.matchPreviousAvailable();\n            }\n            if (this.bufferPosition >= (1 << 14)) {\n                return this.huffmanIsFull(finish);\n            }\n        }\n        return true;\n    };\n    CompressedStreamWriter.prototype.discardMatch = function () {\n        var hashHead = this.insertString();\n        if (hashHead !== 0 && this.stringStart - hashHead <= this.maxDist && this.findLongestMatch(hashHead)) {\n            if (this.matchLength <= 5 && (this.matchLength === 3 && this.stringStart - this.matchStart > 4096)) {\n                this.matchLength = 3 - 1;\n            }\n        }\n    };\n    CompressedStreamWriter.prototype.matchPreviousAvailable = function () {\n        if (this.matchPrevAvail) {\n            this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n        }\n        this.matchPrevAvail = true;\n        this.stringStart++;\n        this.lookAhead--;\n    };\n    CompressedStreamWriter.prototype.matchPreviousBest = function (prevMatch, prevLen) {\n        this.huffmanTallyDist(this.stringStart - 1 - prevMatch, prevLen);\n        prevLen -= 2;\n        do {\n            this.stringStart++;\n            this.lookAhead--;\n            if (this.lookAhead >= 3) {\n                this.insertString();\n            }\n        } while (--prevLen > 0);\n        this.stringStart++;\n        this.lookAhead--;\n        this.matchPrevAvail = false;\n        this.matchLength = 3 - 1;\n        return prevLen;\n    };\n    CompressedStreamWriter.prototype.lookAheadCompleted = function (finish) {\n        if (this.matchPrevAvail) {\n            this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n        }\n        this.matchPrevAvail = false;\n        this.huffmanFlushBlock(this.dataWindow, this.blockStart, this.stringStart - this.blockStart, finish);\n        this.blockStart = this.stringStart;\n        return false;\n    };\n    CompressedStreamWriter.prototype.huffmanIsFull = function (finish) {\n        var len = this.stringStart - this.blockStart;\n        if (this.matchPrevAvail) {\n            len--;\n        }\n        var lastBlock = (finish && this.lookAhead === 0 && !this.matchPrevAvail);\n        this.huffmanFlushBlock(this.dataWindow, this.blockStart, len, lastBlock);\n        this.blockStart += len;\n        return !lastBlock;\n    };\n    CompressedStreamWriter.prototype.fillWindow = function () {\n        if (this.stringStart >= this.windowSize + this.maxDist) {\n            this.slideWindow();\n        }\n        while (this.lookAhead < 262 && this.inputOffset < this.inputEnd) {\n            var more = 2 * this.windowSize - this.lookAhead - this.stringStart;\n            if (more > this.inputEnd - this.inputOffset) {\n                more = this.inputEnd - this.inputOffset;\n            }\n            this.dataWindow.set(this.inputBuffer.subarray(this.inputOffset, this.inputOffset + more), this.stringStart + this.lookAhead);\n            this.inputOffset += more;\n            this.totalBytesIn += more;\n            this.lookAhead += more;\n        }\n        if (this.lookAhead >= 3) {\n            this.updateHash();\n        }\n    };\n    CompressedStreamWriter.prototype.slideWindow = function () {\n        this.dataWindow.set(this.dataWindow.subarray(this.windowSize, this.windowSize + this.windowSize), 0);\n        this.matchStart -= this.windowSize;\n        this.stringStart -= this.windowSize;\n        this.blockStart -= this.windowSize;\n        for (var i = 0; i < this.hashSize; ++i) {\n            var m = this.hashHead[i] & 0xffff;\n            this.hashHead[i] = (((m >= this.windowSize) ? (m - this.windowSize) : 0));\n        }\n        for (var i = 0; i < this.windowSize; i++) {\n            var m = this.hashPrevious[i] & 0xffff;\n            this.hashPrevious[i] = ((m >= this.windowSize) ? (m - this.windowSize) : 0);\n        }\n    };\n    CompressedStreamWriter.prototype.insertString = function () {\n        var match;\n        var hash = ((this.currentHash << this.hashShift) ^ this.dataWindow[this.stringStart + (3 - 1)]) & this.hashMask;\n        this.hashPrevious[this.stringStart & this.windowMask] = match = this.hashHead[hash];\n        this.hashHead[hash] = this.stringStart;\n        this.currentHash = hash;\n        return match & 0xffff;\n    };\n    CompressedStreamWriter.prototype.findLongestMatch = function (curMatch) {\n        var chainLen = 4096;\n        var niceLen = 258;\n        var scan = this.stringStart;\n        var match;\n        var bestEnd = this.stringStart + this.matchLength;\n        var bestLength = Math.max(this.matchLength, 3 - 1);\n        var limit = Math.max(this.stringStart - this.maxDist, 0);\n        var stringEnd = this.stringStart + 258 - 1;\n        var scanEnd1 = this.dataWindow[bestEnd - 1];\n        var scanEnd = this.dataWindow[bestEnd];\n        var data = this.dataWindow;\n        if (bestLength >= 32) {\n            chainLen >>= 2;\n        }\n        if (niceLen > this.lookAhead) {\n            niceLen = this.lookAhead;\n        }\n        do {\n            if (data[curMatch + bestLength] !== scanEnd ||\n                data[curMatch + bestLength - 1] !== scanEnd1 ||\n                data[curMatch] !== data[scan] ||\n                data[curMatch + 1] !== data[scan + 1]) {\n                continue;\n            }\n            match = curMatch + 2;\n            scan += 2;\n            /* tslint:disable */\n            while (data[++scan] === data[++match] && data[++scan] === data[++match] &&\n                data[++scan] === data[++match] && data[++scan] === data[++match] &&\n                data[++scan] === data[++match] && data[++scan] === data[++match] &&\n                data[++scan] === data[++match] && data[++scan] === data[++match] && scan < stringEnd) {\n                /* tslint:disable */\n            }\n            if (scan > bestEnd) {\n                this.matchStart = curMatch;\n                bestEnd = scan;\n                bestLength = scan - this.stringStart;\n                if (bestLength >= niceLen) {\n                    break;\n                }\n                scanEnd1 = data[bestEnd - 1];\n                scanEnd = data[bestEnd];\n            }\n            scan = this.stringStart;\n        } while ((curMatch = (this.hashPrevious[curMatch & this.windowMask] & 0xffff)) > limit && --chainLen !== 0);\n        this.matchLength = Math.min(bestLength, this.lookAhead);\n        return this.matchLength >= 3;\n    };\n    CompressedStreamWriter.prototype.updateHash = function () {\n        this.currentHash = (this.dataWindow[this.stringStart] << this.hashShift) ^ this.dataWindow[this.stringStart + 1];\n    };\n    CompressedStreamWriter.prototype.huffmanTallyLit = function (literal) {\n        this.arrDistances[this.bufferPosition] = 0;\n        this.arrLiterals[this.bufferPosition++] = literal;\n        this.treeLiteral.codeFrequencies[literal]++;\n        return this.bufferPosition >= (1 << 14);\n    };\n    CompressedStreamWriter.prototype.huffmanTallyDist = function (dist, len) {\n        this.arrDistances[this.bufferPosition] = dist;\n        this.arrLiterals[this.bufferPosition++] = (len - 3);\n        var lc = this.huffmanLengthCode(len - 3);\n        this.treeLiteral.codeFrequencies[lc]++;\n        if (lc >= 265 && lc < 285) {\n            this.extraBits += Math.floor((lc - 261) / 4);\n        }\n        var dc = this.huffmanDistanceCode(dist - 1);\n        this.treeDistances.codeFrequencies[dc]++;\n        if (dc >= 4) {\n            this.extraBits += Math.floor((dc / 2 - 1));\n        }\n        return this.bufferPosition >= (1 << 14);\n    };\n    CompressedStreamWriter.prototype.huffmanFlushBlock = function (stored, storedOffset, storedLength, lastBlock) {\n        this.treeLiteral.codeFrequencies[256]++;\n        this.treeLiteral.buildTree();\n        this.treeDistances.buildTree();\n        this.treeLiteral.calculateBLFreq(this.treeCodeLengths);\n        this.treeDistances.calculateBLFreq(this.treeCodeLengths);\n        this.treeCodeLengths.buildTree();\n        var blTreeCodes = 4;\n        for (var i = 18; i > blTreeCodes; i--) {\n            if (this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[i]] > 0) {\n                blTreeCodes = i + 1;\n            }\n        }\n        var opt_len = 14 + blTreeCodes * 3 + this.treeCodeLengths.getEncodedLength() +\n            this.treeLiteral.getEncodedLength() + this.treeDistances.getEncodedLength() + this.extraBits;\n        var static_len = this.extraBits;\n        for (var i = 0; i < 286; i++) {\n            static_len += this.treeLiteral.codeFrequencies[i] * ARR_LITERAL_LENGTHS[i];\n        }\n        for (var i = 0; i < 30; i++) {\n            static_len += this.treeDistances.codeFrequencies[i] * ARR_DISTANCE_LENGTHS[i];\n        }\n        if (opt_len >= static_len) {\n            // Force static trees.\n            opt_len = static_len;\n        }\n        if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {\n            this.huffmanFlushStoredBlock(stored, storedOffset, storedLength, lastBlock);\n        }\n        else if (opt_len == static_len) {\n            // Encode with static tree.\n            this.pendingBufferWriteBits((1 << 1) + (lastBlock ? 1 : 0), 3);\n            this.treeLiteral.setStaticCodes(ARR_LITERAL_CODES, ARR_LITERAL_LENGTHS);\n            this.treeDistances.setStaticCodes(ARR_DISTANCE_CODES, ARR_DISTANCE_LENGTHS);\n            this.huffmanCompressBlock();\n            this.huffmanReset();\n        }\n        else {\n            this.pendingBufferWriteBits((2 << 1) + (lastBlock ? 1 : 0), 3);\n            this.huffmanSendAllTrees(blTreeCodes);\n            this.huffmanCompressBlock();\n            this.huffmanReset();\n        }\n    };\n    CompressedStreamWriter.prototype.huffmanFlushStoredBlock = function (stored, storedOffset, storedLength, lastBlock) {\n        this.pendingBufferWriteBits((0 << 1) + (lastBlock ? 1 : 0), 3);\n        this.pendingBufferAlignToByte();\n        this.pendingBufferWriteShort(storedLength);\n        this.pendingBufferWriteShort(~storedLength);\n        this.pendingBufferWriteByteBlock(stored, storedOffset, storedLength);\n        this.huffmanReset();\n    };\n    CompressedStreamWriter.prototype.huffmanLengthCode = function (len) {\n        if (len === 255) {\n            return 285;\n        }\n        var code = 257;\n        while (len >= 8) {\n            code += 4;\n            len >>= 1;\n        }\n        return code + len;\n    };\n    CompressedStreamWriter.prototype.huffmanDistanceCode = function (distance) {\n        var code = 0;\n        while (distance >= 4) {\n            code += 2;\n            distance >>= 1;\n        }\n        return code + distance;\n    };\n    CompressedStreamWriter.prototype.huffmanSendAllTrees = function (blTreeCodes) {\n        this.treeCodeLengths.buildCodes();\n        this.treeLiteral.buildCodes();\n        this.treeDistances.buildCodes();\n        this.pendingBufferWriteBits(this.treeLiteral.treeLength - 257, 5);\n        this.pendingBufferWriteBits(this.treeDistances.treeLength - 1, 5);\n        this.pendingBufferWriteBits(blTreeCodes - 4, 4);\n        for (var rank = 0; rank < blTreeCodes; rank++) {\n            this.pendingBufferWriteBits(this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[rank]], 3);\n        }\n        this.treeLiteral.writeTree(this.treeCodeLengths);\n        this.treeDistances.writeTree(this.treeCodeLengths);\n    };\n    CompressedStreamWriter.prototype.huffmanReset = function () {\n        this.bufferPosition = 0;\n        this.extraBits = 0;\n        this.treeLiteral.reset();\n        this.treeDistances.reset();\n        this.treeCodeLengths.reset();\n    };\n    CompressedStreamWriter.prototype.huffmanCompressBlock = function () {\n        for (var i = 0; i < this.bufferPosition; i++) {\n            var literalLen = this.arrLiterals[i] & 255;\n            var dist = this.arrDistances[i];\n            if (dist-- !== 0) {\n                var lc = this.huffmanLengthCode(literalLen);\n                this.treeLiteral.writeCodeToStream(lc);\n                var bits = Math.floor((lc - 261) / 4);\n                if (bits > 0 && bits <= 5) {\n                    this.pendingBufferWriteBits(literalLen & ((1 << bits) - 1), bits);\n                }\n                var dc = this.huffmanDistanceCode(dist);\n                this.treeDistances.writeCodeToStream(dc);\n                bits = Math.floor(dc / 2 - 1);\n                if (bits > 0) {\n                    this.pendingBufferWriteBits(dist & ((1 << bits) - 1), bits);\n                }\n            }\n            else {\n                this.treeLiteral.writeCodeToStream(literalLen);\n            }\n        }\n        this.treeLiteral.writeCodeToStream(256);\n    };\n    /**\n     * write bits in to internal buffer\n     * @param {number} b - source of bits\n     * @param {number} count - count of bits to write\n     */\n    CompressedStreamWriter.prototype.pendingBufferWriteBits = function (b, count) {\n        var uint = new Uint32Array(1);\n        uint[0] = this.pendingBufCache | (b << this.pendingBufBitsInCache);\n        this.pendingBufCache = uint[0];\n        this.pendingBufBitsInCache += count;\n        this.pendingBufferFlushBits();\n    };\n    CompressedStreamWriter.prototype.pendingBufferFlush = function (isClose) {\n        this.pendingBufferFlushBits();\n        if (this.pendingBufLength > 0) {\n            var array = new Uint8Array(this.pendingBufLength);\n            array.set(this.pendingBuffer.subarray(0, this.pendingBufLength), 0);\n            this.stream.push(array);\n        }\n        this.pendingBufLength = 0;\n    };\n    CompressedStreamWriter.prototype.pendingBufferFlushBits = function () {\n        var result = 0;\n        while (this.pendingBufBitsInCache >= 8 && this.pendingBufLength < (1 << 16)) {\n            this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n            this.pendingBufCache >>= 8;\n            this.pendingBufBitsInCache -= 8;\n            result++;\n        }\n        return result;\n    };\n    CompressedStreamWriter.prototype.pendingBufferWriteByteBlock = function (data, offset, length) {\n        var array = data.subarray(offset, offset + length);\n        this.pendingBuffer.set(array, this.pendingBufLength);\n        this.pendingBufLength += length;\n    };\n    CompressedStreamWriter.prototype.pendingBufferWriteShort = function (s) {\n        this.pendingBuffer[this.pendingBufLength++] = s;\n        this.pendingBuffer[this.pendingBufLength++] = (s >> 8);\n    };\n    CompressedStreamWriter.prototype.pendingBufferAlignToByte = function () {\n        if (this.pendingBufBitsInCache > 0) {\n            this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n        }\n        this.pendingBufCache = 0;\n        this.pendingBufBitsInCache = 0;\n    };\n    /**\n     * Huffman Tree literal calculation\n     * @private\n     */\n    CompressedStreamWriter.initHuffmanTree = function () {\n        var i = 0;\n        while (i < 144) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x030 + i) << 8);\n            ARR_LITERAL_LENGTHS[i++] = 8;\n        }\n        while (i < 256) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x190 - 144 + i) << 7);\n            ARR_LITERAL_LENGTHS[i++] = 9;\n        }\n        while (i < 280) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x000 - 256 + i) << 9);\n            ARR_LITERAL_LENGTHS[i++] = 7;\n        }\n        while (i < 286) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x0c0 - 280 + i) << 8);\n            ARR_LITERAL_LENGTHS[i++] = 8;\n        }\n        for (i = 0; i < 30; i++) {\n            ARR_DISTANCE_CODES[i] = CompressorHuffmanTree.bitReverse(i << 11);\n            ARR_DISTANCE_LENGTHS[i] = 5;\n        }\n    };\n    /**\n     * close the stream and write all pending buffer in to stream\n     * @returns {void}\n     */\n    CompressedStreamWriter.prototype.close = function () {\n        do {\n            this.pendingBufferFlush(true);\n            if (!this.compressData(true)) {\n                this.pendingBufferFlush(true);\n                this.pendingBufferAlignToByte();\n                if (!this.noWrap) {\n                    this.pendingBufferWriteShortBytes(this.checkSum >> 16);\n                    this.pendingBufferWriteShortBytes(this.checkSum & 0xffff);\n                }\n                this.pendingBufferFlush(true);\n            }\n        } while (!(this.inputEnd === this.inputOffset) ||\n            !(this.pendingBufLength === 0));\n    };\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n    CompressedStreamWriter.prototype.destroy = function () {\n        this.stream = [];\n        this.stream = undefined;\n        this.pendingBuffer = undefined;\n        this.treeLiteral = undefined;\n        this.treeDistances = undefined;\n        this.treeCodeLengths = undefined;\n        this.arrLiterals = undefined;\n        this.arrDistances = undefined;\n        this.hashHead = undefined;\n        this.hashPrevious = undefined;\n        this.dataWindow = undefined;\n        this.inputBuffer = undefined;\n        this.pendingBufLength = undefined;\n        this.pendingBufCache = undefined;\n        this.pendingBufBitsInCache = undefined;\n        this.bufferPosition = undefined;\n        this.extraBits = undefined;\n        this.currentHash = undefined;\n        this.matchStart = undefined;\n        this.matchLength = undefined;\n        this.matchPrevAvail = undefined;\n        this.blockStart = undefined;\n        this.stringStart = undefined;\n        this.lookAhead = undefined;\n        this.totalBytesIn = undefined;\n        this.inputOffset = undefined;\n        this.inputEnd = undefined;\n        this.windowSize = undefined;\n        this.windowMask = undefined;\n        this.hashSize = undefined;\n        this.hashMask = undefined;\n        this.hashShift = undefined;\n        this.maxDist = undefined;\n        this.checkSum = undefined;\n        this.noWrap = undefined;\n    };\n    CompressedStreamWriter.isHuffmanTreeInitiated = false;\n    return CompressedStreamWriter;\n}());\nexport { CompressedStreamWriter };\n/**\n * represent the Huffman Tree\n */\nvar CompressorHuffmanTree = /** @class */ (function () {\n    /**\n     * Create new Huffman Tree\n     * @param {CompressedStreamWriter} writer instance\n     * @param {number} elementCount - element count\n     * @param {number} minCodes - minimum count\n     * @param {number} maxLength - maximum count\n     */\n    function CompressorHuffmanTree(writer, elementCount, minCodes, maxLength) {\n        this.writer = writer;\n        this.codeMinCount = minCodes;\n        this.maxLength = maxLength;\n        this.codeFrequency = new Uint16Array(elementCount);\n        this.lengthCount = new Int32Array(maxLength);\n    }\n    Object.defineProperty(CompressorHuffmanTree.prototype, \"treeLength\", {\n        get: function () {\n            return this.codeCount;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CompressorHuffmanTree.prototype, \"codeLengths\", {\n        get: function () {\n            return this.codeLength;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CompressorHuffmanTree.prototype, \"codeFrequencies\", {\n        get: function () {\n            return this.codeFrequency;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    CompressorHuffmanTree.prototype.setStaticCodes = function (codes, lengths) {\n        var temp = new Int16Array(codes.length);\n        temp.set(codes, 0);\n        this.codes = temp;\n        var lengthTemp = new Uint8Array(lengths.length);\n        lengthTemp.set(lengths, 0);\n        this.codeLength = lengthTemp;\n    };\n    /**\n     * reset all code data in tree\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.reset = function () {\n        for (var i = 0; i < this.codeFrequency.length; i++) {\n            this.codeFrequency[i] = 0;\n        }\n        this.codes = undefined;\n        this.codeLength = undefined;\n    };\n    /**\n     * write code to the compressor output stream\n     * @param {number} code - code to be written\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.writeCodeToStream = function (code) {\n        this.writer.pendingBufferWriteBits(this.codes[code] & 0xffff, this.codeLength[code]);\n    };\n    /**\n     * calculate code from their frequencies\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.buildCodes = function () {\n        var nextCode = new Int32Array(this.maxLength);\n        this.codes = new Int16Array(this.codeCount);\n        var code = 0;\n        for (var bitsCount = 0; bitsCount < this.maxLength; bitsCount++) {\n            nextCode[bitsCount] = code;\n            code += this.lengthCount[bitsCount] << (15 - bitsCount);\n        }\n        for (var i = 0; i < this.codeCount; i++) {\n            var bits = this.codeLength[i];\n            if (bits > 0) {\n                this.codes[i] = CompressorHuffmanTree.bitReverse(nextCode[bits - 1]);\n                nextCode[bits - 1] += 1 << (16 - bits);\n            }\n        }\n    };\n    CompressorHuffmanTree.bitReverse = function (value) {\n        return (CompressorHuffmanTree.reverseBits[value & 15] << 12\n            | CompressorHuffmanTree.reverseBits[(value >> 4) & 15] << 8\n            | CompressorHuffmanTree.reverseBits[(value >> 8) & 15] << 4\n            | CompressorHuffmanTree.reverseBits[value >> 12]);\n    };\n    /**\n     * calculate length of compressed data\n     * @returns {number}\n     */\n    CompressorHuffmanTree.prototype.getEncodedLength = function () {\n        var len = 0;\n        for (var i = 0; i < this.codeFrequency.length; i++) {\n            len += this.codeFrequency[i] * this.codeLength[i];\n        }\n        return len;\n    };\n    /**\n     * calculate code frequencies\n     * @param {CompressorHuffmanTree} blTree\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.calculateBLFreq = function (blTree) {\n        var maxCount;\n        var minCount;\n        var count;\n        var curLen = -1;\n        var i = 0;\n        while (i < this.codeCount) {\n            count = 1;\n            var nextLen = this.codeLength[i];\n            if (nextLen === 0) {\n                maxCount = 138;\n                minCount = 3;\n            }\n            else {\n                maxCount = 6;\n                minCount = 3;\n                if (curLen !== nextLen) {\n                    blTree.codeFrequency[nextLen]++;\n                    count = 0;\n                }\n            }\n            curLen = nextLen;\n            i++;\n            while (i < this.codeCount && curLen === this.codeLength[i]) {\n                i++;\n                if (++count >= maxCount) {\n                    break;\n                }\n            }\n            if (count < minCount) {\n                blTree.codeFrequency[curLen] += count;\n            }\n            else if (curLen !== 0) {\n                blTree.codeFrequency[16]++;\n            }\n            else if (count <= 10) {\n                blTree.codeFrequency[17]++;\n            }\n            else {\n                blTree.codeFrequency[18]++;\n            }\n        }\n    };\n    /**\n     * @param {CompressorHuffmanTree} blTree - write tree to output stream\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.writeTree = function (blTree) {\n        var maxRepeatCount;\n        var minRepeatCount;\n        var currentRepeatCount;\n        var currentCodeLength = -1;\n        var i = 0;\n        while (i < this.codeCount) {\n            currentRepeatCount = 1;\n            var nextLen = this.codeLength[i];\n            if (nextLen === 0) {\n                maxRepeatCount = 138;\n                minRepeatCount = 3;\n            }\n            else {\n                maxRepeatCount = 6;\n                minRepeatCount = 3;\n                if (currentCodeLength !== nextLen) {\n                    blTree.writeCodeToStream(nextLen);\n                    currentRepeatCount = 0;\n                }\n            }\n            currentCodeLength = nextLen;\n            i++;\n            while (i < this.codeCount && currentCodeLength === this.codeLength[i]) {\n                i++;\n                if (++currentRepeatCount >= maxRepeatCount) {\n                    break;\n                }\n            }\n            if (currentRepeatCount < minRepeatCount) {\n                while (currentRepeatCount-- > 0) {\n                    blTree.writeCodeToStream(currentCodeLength);\n                }\n            }\n            else if (currentCodeLength !== 0) {\n                blTree.writeCodeToStream(16);\n                this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 2);\n            }\n            else if (currentRepeatCount <= 10) {\n                blTree.writeCodeToStream(17);\n                this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 3);\n            }\n            else {\n                blTree.writeCodeToStream(18);\n                this.writer.pendingBufferWriteBits(currentRepeatCount - 11, 7);\n            }\n        }\n    };\n    /**\n     * Build huffman tree\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.buildTree = function () {\n        var codesCount = this.codeFrequency.length;\n        var arrTree = new Int32Array(codesCount);\n        var treeLength = 0;\n        var maxCount = 0;\n        for (var n = 0; n < codesCount; n++) {\n            var freq = this.codeFrequency[n];\n            if (freq !== 0) {\n                var pos = treeLength++;\n                var pPos = 0;\n                while (pos > 0 && this.codeFrequency[arrTree[pPos = Math.floor((pos - 1) / 2)]] > freq) {\n                    arrTree[pos] = arrTree[pPos];\n                    pos = pPos;\n                }\n                arrTree[pos] = n;\n                maxCount = n;\n            }\n        }\n        while (treeLength < 2) {\n            arrTree[treeLength++] =\n                (maxCount < 2) ? ++maxCount : 0;\n        }\n        this.codeCount = Math.max(maxCount + 1, this.codeMinCount);\n        var leafsCount = treeLength;\n        var nodesCount = leafsCount;\n        var child = new Int32Array(4 * treeLength - 2);\n        var values = new Int32Array(2 * treeLength - 1);\n        for (var i = 0; i < treeLength; i++) {\n            var node = arrTree[i];\n            var iIndex = 2 * i;\n            child[iIndex] = node;\n            child[iIndex + 1] = -1;\n            values[i] = (this.codeFrequency[node] << 8);\n            arrTree[i] = i;\n        }\n        this.constructHuffmanTree(arrTree, treeLength, values, nodesCount, child);\n        this.buildLength(child);\n    };\n    CompressorHuffmanTree.prototype.constructHuffmanTree = function (arrTree, treeLength, values, nodesCount, child) {\n        do {\n            var first = arrTree[0];\n            var last = arrTree[--treeLength];\n            var lastVal = values[last];\n            var pPos = 0;\n            var path = 1;\n            while (path < treeLength) {\n                if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n                    path++;\n                }\n                arrTree[pPos] = arrTree[path];\n                pPos = path;\n                path = pPos * 2 + 1;\n            }\n            while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n                arrTree[path] = arrTree[pPos];\n            }\n            arrTree[path] = last;\n            var second = arrTree[0];\n            last = nodesCount++;\n            child[2 * last] = first;\n            child[2 * last + 1] = second;\n            var minDepth = Math.min(values[first] & 0xff, values[second] & 0xff);\n            values[last] = lastVal = values[first] + values[second] - minDepth + 1;\n            pPos = 0;\n            path = 1;\n            /* tslint:disable */\n            while (path < treeLength) {\n                if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n                    path++;\n                }\n                arrTree[pPos] = arrTree[path];\n                pPos = path;\n                path = pPos * 2 + 1;\n            } /* tslint:disable */\n            while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n                arrTree[path] = arrTree[pPos];\n            }\n            arrTree[path] = last;\n        } while (treeLength > 1);\n    };\n    CompressorHuffmanTree.prototype.buildLength = function (child) {\n        this.codeLength = new Uint8Array(this.codeFrequency.length);\n        var numNodes = Math.floor(child.length / 2);\n        var numLeafs = Math.floor((numNodes + 1) / 2);\n        var overflow = 0;\n        for (var i = 0; i < this.maxLength; i++) {\n            this.lengthCount[i] = 0;\n        }\n        overflow = this.calculateOptimalCodeLength(child, overflow, numNodes);\n        if (overflow === 0) {\n            return;\n        }\n        var iIncreasableLength = this.maxLength - 1;\n        do {\n            while (this.lengthCount[--iIncreasableLength] === 0) {\n                /* tslint:disable */\n            }\n            do {\n                this.lengthCount[iIncreasableLength]--;\n                this.lengthCount[++iIncreasableLength]++;\n                overflow -= (1 << (this.maxLength - 1 - iIncreasableLength));\n            } while (overflow > 0 && iIncreasableLength < this.maxLength - 1);\n        } while (overflow > 0);\n        this.recreateTree(child, overflow, numLeafs);\n    };\n    CompressorHuffmanTree.prototype.recreateTree = function (child, overflow, numLeafs) {\n        this.lengthCount[this.maxLength - 1] += overflow;\n        this.lengthCount[this.maxLength - 2] -= overflow;\n        var nodePtr = 2 * numLeafs;\n        for (var bits = this.maxLength; bits !== 0; bits--) {\n            var n = this.lengthCount[bits - 1];\n            while (n > 0) {\n                var childPtr = 2 * child[nodePtr++];\n                if (child[childPtr + 1] === -1) {\n                    this.codeLength[child[childPtr]] = bits;\n                    n--;\n                }\n            }\n        }\n    };\n    CompressorHuffmanTree.prototype.calculateOptimalCodeLength = function (child, overflow, numNodes) {\n        var lengths = new Int32Array(numNodes);\n        lengths[numNodes - 1] = 0;\n        for (var i = numNodes - 1; i >= 0; i--) {\n            var childIndex = 2 * i + 1;\n            if (child[childIndex] !== -1) {\n                var bitLength = lengths[i] + 1;\n                if (bitLength > this.maxLength) {\n                    bitLength = this.maxLength;\n                    overflow++;\n                }\n                lengths[child[childIndex - 1]] = lengths[child[childIndex]] = bitLength;\n            }\n            else {\n                var bitLength = lengths[i];\n                this.lengthCount[bitLength - 1]++;\n                this.codeLength[child[childIndex - 1]] = lengths[i];\n            }\n        }\n        return overflow;\n    };\n    CompressorHuffmanTree.reverseBits = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];\n    CompressorHuffmanTree.huffCodeLengthOrders = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n    return CompressorHuffmanTree;\n}());\nexport { CompressorHuffmanTree };\n/**\n * Checksum calculator, based on Adler32 algorithm.\n */\nvar ChecksumCalculator = /** @class */ (function () {\n    function ChecksumCalculator() {\n    }\n    /**\n     * Updates checksum by calculating checksum of the\n     * given buffer and adding it to current value.\n     * @param {number} checksum - current checksum.\n     * @param {Uint8Array} buffer - data byte array.\n     * @param {number} offset - offset in the buffer.\n     * @param {number} length - length of data to be used from the stream.\n     * @returns {number}\n     */\n    ChecksumCalculator.checksumUpdate = function (checksum, buffer, offset, length) {\n        var uint = new Uint32Array(1);\n        uint[0] = checksum;\n        var checksum_uint = uint[0];\n        var s1 = uint[0] = checksum_uint & 65535;\n        var s2 = uint[0] = checksum_uint >> ChecksumCalculator.checkSumBitOffset;\n        while (length > 0) {\n            var steps = Math.min(length, ChecksumCalculator.checksumIterationCount);\n            length -= steps;\n            while (--steps >= 0) {\n                s1 = s1 + (uint[0] = (buffer[offset++] & 255));\n                s2 = s2 + s1;\n            }\n            s1 %= ChecksumCalculator.checksumBase;\n            s2 %= ChecksumCalculator.checksumBase;\n        }\n        checksum_uint = (s2 << ChecksumCalculator.checkSumBitOffset) | s1;\n        return checksum_uint;\n    };\n    ChecksumCalculator.checkSumBitOffset = 16;\n    ChecksumCalculator.checksumBase = 65521;\n    ChecksumCalculator.checksumIterationCount = 3800;\n    return ChecksumCalculator;\n}());\nexport { ChecksumCalculator };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}