{"ast":null,"code":"/**\n * Encoding class: Contains the details about encoding type, whether to write a Unicode byte order mark (BOM).\n * ```typescript\n * let encoding : Encoding = new Encoding();\n * encoding.type = 'Utf8';\n * encoding.getBytes('Encoding', 0, 5);\n * ```\n */\nvar Encoding = /** @class */function () {\n  /**\n   * Initializes a new instance of the Encoding class. A parameter specifies whether to write a Unicode byte order mark\n   * @param  {boolean} includeBom?-true to specify that a Unicode byte order mark is written; otherwise, false.\n   */\n  function Encoding(includeBom) {\n    this.emitBOM = true;\n    this.encodingType = 'Ansi';\n    this.initBOM(includeBom);\n  }\n  Object.defineProperty(Encoding.prototype, \"includeBom\", {\n    /**\n     * Gets a value indicating whether to write a Unicode byte order mark\n     * @returns boolean- true to specify that a Unicode byte order mark is written; otherwise, false\n     */\n    get: function () {\n      return this.emitBOM;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Encoding.prototype, \"type\", {\n    /**\n     * Gets the encoding type.\n     * @returns EncodingType\n     */\n    get: function () {\n      return this.encodingType;\n    },\n    /**\n     * Sets the encoding type.\n     * @param  {EncodingType} value\n     */\n    set: function (value) {\n      this.encodingType = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Initialize the includeBom to emit BOM or Not\n   * @param  {boolean} includeBom\n   */\n  Encoding.prototype.initBOM = function (includeBom) {\n    if (includeBom === undefined || includeBom === null) {\n      this.emitBOM = true;\n    } else {\n      this.emitBOM = includeBom;\n    }\n  };\n  /**\n   * Calculates the number of bytes produced by encoding the characters in the specified string\n   * @param  {string} chars - The string containing the set of characters to encode\n   * @returns {number} - The number of bytes produced by encoding the specified characters\n   */\n  Encoding.prototype.getByteCount = function (chars) {\n    var byteCount = 0;\n    validateNullOrUndefined(chars, 'string');\n    if (chars === '') {\n      var byte = this.utf8Len(chars.charCodeAt(0));\n      return byte;\n    }\n    if (this.type === null || this.type === undefined) {\n      this.type = 'Ansi';\n    }\n    return this.getByteCountInternal(chars, 0, chars.length);\n  };\n  /**\n   * Return the Byte of character\n   * @param  {number} codePoint\n   * @returns {number}\n   */\n  Encoding.prototype.utf8Len = function (codePoint) {\n    var bytes = codePoint <= 0x7F ? 1 : codePoint <= 0x7FF ? 2 : codePoint <= 0xFFFF ? 3 : codePoint <= 0x1FFFFF ? 4 : 0;\n    return bytes;\n  };\n  /**\n   * for 4 byte character return surrogate pair true, otherwise false\n   * @param  {number} codeUnit\n   * @returns {boolean}\n   */\n  Encoding.prototype.isHighSurrogate = function (codeUnit) {\n    return codeUnit >= 0xD800 && codeUnit <= 0xDBFF;\n  };\n  /**\n   * for 4byte character generate the surrogate pair\n   * @param  {number} highCodeUnit\n   * @param  {number} lowCodeUnit\n   */\n  Encoding.prototype.toCodepoint = function (highCodeUnit, lowCodeUnit) {\n    highCodeUnit = (0x3FF & highCodeUnit) << 10;\n    var u = highCodeUnit | 0x3FF & lowCodeUnit;\n    return u + 0x10000;\n  };\n  /**\n   * private method to get the byte count for specific charindex and count\n   * @param  {string} chars\n   * @param  {number} charIndex\n   * @param  {number} charCount\n   */\n  Encoding.prototype.getByteCountInternal = function (chars, charIndex, charCount) {\n    var byteCount = 0;\n    if (this.encodingType === 'Utf8' || this.encodingType === 'Unicode') {\n      var isUtf8 = this.encodingType === 'Utf8';\n      for (var i = 0; i < charCount; i++) {\n        var charCode = chars.charCodeAt(isUtf8 ? charIndex : charIndex++);\n        if (this.isHighSurrogate(charCode)) {\n          if (isUtf8) {\n            var high = charCode;\n            var low = chars.charCodeAt(++charIndex);\n            byteCount += this.utf8Len(this.toCodepoint(high, low));\n          } else {\n            byteCount += 4;\n            ++i;\n          }\n        } else {\n          if (isUtf8) {\n            byteCount += this.utf8Len(charCode);\n          } else {\n            byteCount += 2;\n          }\n        }\n        if (isUtf8) {\n          charIndex++;\n        }\n      }\n      return byteCount;\n    } else {\n      byteCount = charCount;\n      return byteCount;\n    }\n  };\n  /**\n   * Encodes a set of characters from the specified string into the ArrayBuffer.\n   * @param  {string} s- The string containing the set of characters to encode\n   * @param  {number} charIndex-The index of the first character to encode.\n   * @param  {number} charCount- The number of characters to encode.\n   * @returns {ArrayBuffer} - The ArrayBuffer that contains the resulting sequence of bytes.\n   */\n  Encoding.prototype.getBytes = function (s, charIndex, charCount) {\n    validateNullOrUndefined(s, 'string');\n    validateNullOrUndefined(charIndex, 'charIndex');\n    validateNullOrUndefined(charCount, 'charCount');\n    if (charIndex < 0 || charCount < 0) {\n      throw new RangeError('Argument Out Of Range Exception: charIndex or charCount is less than zero');\n    }\n    if (s.length - charIndex < charCount) {\n      throw new RangeError('Argument Out Of Range Exception: charIndex and charCount do not denote a valid range in string');\n    }\n    var bytes;\n    if (s === '') {\n      bytes = new ArrayBuffer(0);\n      return bytes;\n    }\n    if (this.type === null || this.type === undefined) {\n      this.type = 'Ansi';\n    }\n    var byteCount = this.getByteCountInternal(s, charIndex, charCount);\n    switch (this.type) {\n      case 'Utf8':\n        bytes = this.getBytesOfUtf8Encoding(byteCount, s, charIndex, charCount);\n        return bytes;\n      case 'Unicode':\n        bytes = this.getBytesOfUnicodeEncoding(byteCount, s, charIndex, charCount);\n        return bytes;\n      default:\n        bytes = this.getBytesOfAnsiEncoding(byteCount, s, charIndex, charCount);\n        return bytes;\n    }\n  };\n  /**\n   * Decodes a sequence of bytes from the specified ArrayBuffer into the string.\n   * @param  {ArrayBuffer} bytes- The ArrayBuffer containing the sequence of bytes to decode.\n   * @param  {number} index- The index of the first byte to decode.\n   * @param  {number} count- The number of bytes to decode.\n   * @returns {string} - The string that contains the resulting set of characters.\n   */\n  Encoding.prototype.getString = function (bytes, index, count) {\n    validateNullOrUndefined(bytes, 'bytes');\n    validateNullOrUndefined(index, 'index');\n    validateNullOrUndefined(count, 'count');\n    if (index < 0 || count < 0) {\n      throw new RangeError('Argument Out Of Range Exception: index or count is less than zero');\n    }\n    if (bytes.byteLength - index < count) {\n      throw new RangeError('Argument Out Of Range Exception: index and count do not denote a valid range in bytes');\n    }\n    if (bytes.byteLength === 0 || count === 0) {\n      return '';\n    }\n    if (this.type === null || this.type === undefined) {\n      this.type = 'Ansi';\n    }\n    var out = '';\n    var byteCal = new Uint8Array(bytes);\n    switch (this.type) {\n      case 'Utf8':\n        var s = this.getStringOfUtf8Encoding(byteCal, index, count);\n        return s;\n      case 'Unicode':\n        var byteUnicode = new Uint16Array(bytes);\n        out = this.getStringofUnicodeEncoding(byteUnicode, index, count);\n        return out;\n      default:\n        var j = index;\n        for (var i = 0; i < count; i++) {\n          var c = byteCal[j];\n          out += String.fromCharCode(c); // 1 byte(ASCII) character                  \n          j++;\n        }\n        return out;\n    }\n  };\n  Encoding.prototype.getBytesOfAnsiEncoding = function (byteCount, s, charIndex, charCount) {\n    var bytes = new ArrayBuffer(byteCount);\n    var bufview = new Uint8Array(bytes);\n    var k = 0;\n    for (var i = 0; i < charCount; i++) {\n      var charcode = s.charCodeAt(charIndex++);\n      if (charcode < 0x800) {\n        bufview[k] = charcode;\n      } else {\n        bufview[k] = 63; //replacement character '?'\n      }\n\n      k++;\n    }\n    return bytes;\n  };\n  Encoding.prototype.getBytesOfUtf8Encoding = function (byteCount, s, charIndex, charCount) {\n    var bytes = new ArrayBuffer(byteCount);\n    var uint = new Uint8Array(bytes);\n    var index = charIndex;\n    var j = 0;\n    for (var i = 0; i < charCount; i++) {\n      var charcode = s.charCodeAt(index);\n      if (charcode <= 0x7F) {\n        // 1 byte character 2^7\n        uint[j] = charcode;\n      } else if (charcode < 0x800) {\n        // 2 byte character 2^11\n        uint[j] = 0xc0 | charcode >> 6;\n        uint[++j] = 0x80 | charcode & 0x3f;\n      } else if (charcode < 0xd800 || charcode >= 0xe000) {\n        // 3 byte character 2^16        \n        uint[j] = 0xe0 | charcode >> 12;\n        uint[++j] = 0x80 | charcode >> 6 & 0x3f;\n        uint[++j] = 0x80 | charcode & 0x3f;\n      } else {\n        uint[j] = 0xef;\n        uint[++j] = 0xbf;\n        uint[++j] = 0xbd; // U+FFFE \"replacement character\"\n      }\n\n      ++j;\n      ++index;\n    }\n    return bytes;\n  };\n  Encoding.prototype.getBytesOfUnicodeEncoding = function (byteCount, s, charIndex, charCount) {\n    var bytes = new ArrayBuffer(byteCount);\n    var uint16 = new Uint16Array(bytes);\n    for (var i = 0; i < charCount; i++) {\n      var charcode = s.charCodeAt(i);\n      uint16[i] = charcode;\n    }\n    return bytes;\n  };\n  Encoding.prototype.getStringOfUtf8Encoding = function (byteCal, index, count) {\n    var j = 0;\n    var i = index;\n    var s = '';\n    for (j; j < count; j++) {\n      var c = byteCal[i++];\n      while (i > byteCal.length) {\n        return s;\n      }\n      if (c > 127) {\n        if (c > 191 && c < 224 && i < count) {\n          c = (c & 31) << 6 | byteCal[i] & 63;\n        } else if (c > 223 && c < 240 && i < byteCal.byteLength) {\n          c = (c & 15) << 12 | (byteCal[i] & 63) << 6 | byteCal[++i] & 63;\n        } else if (c > 239 && c < 248 && i < byteCal.byteLength) {\n          c = (c & 7) << 18 | (byteCal[i] & 63) << 12 | (byteCal[++i] & 63) << 6 | byteCal[++i] & 63;\n        }\n        ++i;\n      }\n      s += String.fromCharCode(c); // 1 byte(ASCII) character                          \n    }\n\n    return s;\n  };\n  Encoding.prototype.getStringofUnicodeEncoding = function (byteUni, index, count) {\n    if (count > byteUni.length) {\n      throw new RangeError('ArgumentOutOfRange_Count');\n    }\n    var byte16 = new Uint16Array(count);\n    var out = '';\n    for (var i = 0; i < count && i < byteUni.length; i++) {\n      byte16[i] = byteUni[index++];\n    }\n    out = String.fromCharCode.apply(null, byte16);\n    return out;\n  };\n  /**\n   * To clear the encoding instance\n   * @return {void}\n   */\n  Encoding.prototype.destroy = function () {\n    this.emitBOM = undefined;\n    this.encodingType = undefined;\n  };\n  return Encoding;\n}();\nexport { Encoding };\n/**\n * To check the object is null or undefined and throw error if it is null or undefined\n * @param {Object} value - object to check is null or undefined\n * @return {boolean}\n * @throws {ArgumentException} - if the value is null or undefined\n * @private\n */\nexport function validateNullOrUndefined(value, message) {\n  if (value === null || value === undefined) {\n    throw new Error('ArgumentException: ' + message + ' cannot be null or undefined');\n  }\n}","map":{"version":3,"names":["Encoding","includeBom","emitBOM","encodingType","initBOM","Object","defineProperty","prototype","get","enumerable","configurable","set","value","undefined","getByteCount","chars","byteCount","validateNullOrUndefined","byte","utf8Len","charCodeAt","type","getByteCountInternal","length","codePoint","bytes","isHighSurrogate","codeUnit","toCodepoint","highCodeUnit","lowCodeUnit","u","charIndex","charCount","isUtf8","i","charCode","high","low","getBytes","s","RangeError","ArrayBuffer","getBytesOfUtf8Encoding","getBytesOfUnicodeEncoding","getBytesOfAnsiEncoding","getString","index","count","byteLength","out","byteCal","Uint8Array","getStringOfUtf8Encoding","byteUnicode","Uint16Array","getStringofUnicodeEncoding","j","c","String","fromCharCode","bufview","k","charcode","uint","uint16","byteUni","byte16","apply","destroy","message","Error"],"sources":["/Users/macbookpro16/Desktop/cs222/client/node_modules/@syncfusion/ej2-file-utils/src/encoding.js"],"sourcesContent":["/**\n * Encoding class: Contains the details about encoding type, whether to write a Unicode byte order mark (BOM).\n * ```typescript\n * let encoding : Encoding = new Encoding();\n * encoding.type = 'Utf8';\n * encoding.getBytes('Encoding', 0, 5);\n * ```\n */\nvar Encoding = /** @class */ (function () {\n    /**\n     * Initializes a new instance of the Encoding class. A parameter specifies whether to write a Unicode byte order mark\n     * @param  {boolean} includeBom?-true to specify that a Unicode byte order mark is written; otherwise, false.\n     */\n    function Encoding(includeBom) {\n        this.emitBOM = true;\n        this.encodingType = 'Ansi';\n        this.initBOM(includeBom);\n    }\n    Object.defineProperty(Encoding.prototype, \"includeBom\", {\n        /**\n         * Gets a value indicating whether to write a Unicode byte order mark\n         * @returns boolean- true to specify that a Unicode byte order mark is written; otherwise, false\n         */\n        get: function () {\n            return this.emitBOM;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Encoding.prototype, \"type\", {\n        /**\n         * Gets the encoding type.\n         * @returns EncodingType\n         */\n        get: function () {\n            return this.encodingType;\n        },\n        /**\n         * Sets the encoding type.\n         * @param  {EncodingType} value\n         */\n        set: function (value) {\n            this.encodingType = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Initialize the includeBom to emit BOM or Not\n     * @param  {boolean} includeBom\n     */\n    Encoding.prototype.initBOM = function (includeBom) {\n        if (includeBom === undefined || includeBom === null) {\n            this.emitBOM = true;\n        }\n        else {\n            this.emitBOM = includeBom;\n        }\n    };\n    /**\n     * Calculates the number of bytes produced by encoding the characters in the specified string\n     * @param  {string} chars - The string containing the set of characters to encode\n     * @returns {number} - The number of bytes produced by encoding the specified characters\n     */\n    Encoding.prototype.getByteCount = function (chars) {\n        var byteCount = 0;\n        validateNullOrUndefined(chars, 'string');\n        if (chars === '') {\n            var byte = this.utf8Len(chars.charCodeAt(0));\n            return byte;\n        }\n        if (this.type === null || this.type === undefined) {\n            this.type = 'Ansi';\n        }\n        return this.getByteCountInternal(chars, 0, chars.length);\n    };\n    /**\n     * Return the Byte of character\n     * @param  {number} codePoint\n     * @returns {number}\n     */\n    Encoding.prototype.utf8Len = function (codePoint) {\n        var bytes = codePoint <= 0x7F ? 1 :\n            codePoint <= 0x7FF ? 2 :\n                codePoint <= 0xFFFF ? 3 :\n                    codePoint <= 0x1FFFFF ? 4 : 0;\n        return bytes;\n    };\n    /**\n     * for 4 byte character return surrogate pair true, otherwise false\n     * @param  {number} codeUnit\n     * @returns {boolean}\n     */\n    Encoding.prototype.isHighSurrogate = function (codeUnit) {\n        return codeUnit >= 0xD800 && codeUnit <= 0xDBFF;\n    };\n    /**\n     * for 4byte character generate the surrogate pair\n     * @param  {number} highCodeUnit\n     * @param  {number} lowCodeUnit\n     */\n    Encoding.prototype.toCodepoint = function (highCodeUnit, lowCodeUnit) {\n        highCodeUnit = (0x3FF & highCodeUnit) << 10;\n        var u = highCodeUnit | (0x3FF & lowCodeUnit);\n        return u + 0x10000;\n    };\n    /**\n     * private method to get the byte count for specific charindex and count\n     * @param  {string} chars\n     * @param  {number} charIndex\n     * @param  {number} charCount\n     */\n    Encoding.prototype.getByteCountInternal = function (chars, charIndex, charCount) {\n        var byteCount = 0;\n        if (this.encodingType === 'Utf8' || this.encodingType === 'Unicode') {\n            var isUtf8 = this.encodingType === 'Utf8';\n            for (var i = 0; i < charCount; i++) {\n                var charCode = chars.charCodeAt(isUtf8 ? charIndex : charIndex++);\n                if (this.isHighSurrogate(charCode)) {\n                    if (isUtf8) {\n                        var high = charCode;\n                        var low = chars.charCodeAt(++charIndex);\n                        byteCount += this.utf8Len(this.toCodepoint(high, low));\n                    }\n                    else {\n                        byteCount += 4;\n                        ++i;\n                    }\n                }\n                else {\n                    if (isUtf8) {\n                        byteCount += this.utf8Len(charCode);\n                    }\n                    else {\n                        byteCount += 2;\n                    }\n                }\n                if (isUtf8) {\n                    charIndex++;\n                }\n            }\n            return byteCount;\n        }\n        else {\n            byteCount = charCount;\n            return byteCount;\n        }\n    };\n    /**\n     * Encodes a set of characters from the specified string into the ArrayBuffer.\n     * @param  {string} s- The string containing the set of characters to encode\n     * @param  {number} charIndex-The index of the first character to encode.\n     * @param  {number} charCount- The number of characters to encode.\n     * @returns {ArrayBuffer} - The ArrayBuffer that contains the resulting sequence of bytes.\n     */\n    Encoding.prototype.getBytes = function (s, charIndex, charCount) {\n        validateNullOrUndefined(s, 'string');\n        validateNullOrUndefined(charIndex, 'charIndex');\n        validateNullOrUndefined(charCount, 'charCount');\n        if (charIndex < 0 || charCount < 0) {\n            throw new RangeError('Argument Out Of Range Exception: charIndex or charCount is less than zero');\n        }\n        if (s.length - charIndex < charCount) {\n            throw new RangeError('Argument Out Of Range Exception: charIndex and charCount do not denote a valid range in string');\n        }\n        var bytes;\n        if (s === '') {\n            bytes = new ArrayBuffer(0);\n            return bytes;\n        }\n        if (this.type === null || this.type === undefined) {\n            this.type = 'Ansi';\n        }\n        var byteCount = this.getByteCountInternal(s, charIndex, charCount);\n        switch (this.type) {\n            case 'Utf8':\n                bytes = this.getBytesOfUtf8Encoding(byteCount, s, charIndex, charCount);\n                return bytes;\n            case 'Unicode':\n                bytes = this.getBytesOfUnicodeEncoding(byteCount, s, charIndex, charCount);\n                return bytes;\n            default:\n                bytes = this.getBytesOfAnsiEncoding(byteCount, s, charIndex, charCount);\n                return bytes;\n        }\n    };\n    /**\n     * Decodes a sequence of bytes from the specified ArrayBuffer into the string.\n     * @param  {ArrayBuffer} bytes- The ArrayBuffer containing the sequence of bytes to decode.\n     * @param  {number} index- The index of the first byte to decode.\n     * @param  {number} count- The number of bytes to decode.\n     * @returns {string} - The string that contains the resulting set of characters.\n     */\n    Encoding.prototype.getString = function (bytes, index, count) {\n        validateNullOrUndefined(bytes, 'bytes');\n        validateNullOrUndefined(index, 'index');\n        validateNullOrUndefined(count, 'count');\n        if (index < 0 || count < 0) {\n            throw new RangeError('Argument Out Of Range Exception: index or count is less than zero');\n        }\n        if (bytes.byteLength - index < count) {\n            throw new RangeError('Argument Out Of Range Exception: index and count do not denote a valid range in bytes');\n        }\n        if (bytes.byteLength === 0 || count === 0) {\n            return '';\n        }\n        if (this.type === null || this.type === undefined) {\n            this.type = 'Ansi';\n        }\n        var out = '';\n        var byteCal = new Uint8Array(bytes);\n        switch (this.type) {\n            case 'Utf8':\n                var s = this.getStringOfUtf8Encoding(byteCal, index, count);\n                return s;\n            case 'Unicode':\n                var byteUnicode = new Uint16Array(bytes);\n                out = this.getStringofUnicodeEncoding(byteUnicode, index, count);\n                return out;\n            default:\n                var j = index;\n                for (var i = 0; i < count; i++) {\n                    var c = byteCal[j];\n                    out += String.fromCharCode(c); // 1 byte(ASCII) character                  \n                    j++;\n                }\n                return out;\n        }\n    };\n    Encoding.prototype.getBytesOfAnsiEncoding = function (byteCount, s, charIndex, charCount) {\n        var bytes = new ArrayBuffer(byteCount);\n        var bufview = new Uint8Array(bytes);\n        var k = 0;\n        for (var i = 0; i < charCount; i++) {\n            var charcode = s.charCodeAt(charIndex++);\n            if (charcode < 0x800) {\n                bufview[k] = charcode;\n            }\n            else {\n                bufview[k] = 63; //replacement character '?'\n            }\n            k++;\n        }\n        return bytes;\n    };\n    Encoding.prototype.getBytesOfUtf8Encoding = function (byteCount, s, charIndex, charCount) {\n        var bytes = new ArrayBuffer(byteCount);\n        var uint = new Uint8Array(bytes);\n        var index = charIndex;\n        var j = 0;\n        for (var i = 0; i < charCount; i++) {\n            var charcode = s.charCodeAt(index);\n            if (charcode <= 0x7F) { // 1 byte character 2^7\n                uint[j] = charcode;\n            }\n            else if (charcode < 0x800) { // 2 byte character 2^11\n                uint[j] = 0xc0 | (charcode >> 6);\n                uint[++j] = 0x80 | (charcode & 0x3f);\n            }\n            else if ((charcode < 0xd800 || charcode >= 0xe000)) { // 3 byte character 2^16        \n                uint[j] = 0xe0 | (charcode >> 12);\n                uint[++j] = 0x80 | ((charcode >> 6) & 0x3f);\n                uint[++j] = 0x80 | (charcode & 0x3f);\n            }\n            else {\n                uint[j] = 0xef;\n                uint[++j] = 0xbf;\n                uint[++j] = 0xbd; // U+FFFE \"replacement character\"\n            }\n            ++j;\n            ++index;\n        }\n        return bytes;\n    };\n    Encoding.prototype.getBytesOfUnicodeEncoding = function (byteCount, s, charIndex, charCount) {\n        var bytes = new ArrayBuffer(byteCount);\n        var uint16 = new Uint16Array(bytes);\n        for (var i = 0; i < charCount; i++) {\n            var charcode = s.charCodeAt(i);\n            uint16[i] = charcode;\n        }\n        return bytes;\n    };\n    Encoding.prototype.getStringOfUtf8Encoding = function (byteCal, index, count) {\n        var j = 0;\n        var i = index;\n        var s = '';\n        for (j; j < count; j++) {\n            var c = byteCal[i++];\n            while (i > byteCal.length) {\n                return s;\n            }\n            if (c > 127) {\n                if (c > 191 && c < 224 && i < count) {\n                    c = (c & 31) << 6 | byteCal[i] & 63;\n                }\n                else if (c > 223 && c < 240 && i < byteCal.byteLength) {\n                    c = (c & 15) << 12 | (byteCal[i] & 63) << 6 | byteCal[++i] & 63;\n                }\n                else if (c > 239 && c < 248 && i < byteCal.byteLength) {\n                    c = (c & 7) << 18 | (byteCal[i] & 63) << 12 | (byteCal[++i] & 63) << 6 | byteCal[++i] & 63;\n                }\n                ++i;\n            }\n            s += String.fromCharCode(c); // 1 byte(ASCII) character                          \n        }\n        return s;\n    };\n    Encoding.prototype.getStringofUnicodeEncoding = function (byteUni, index, count) {\n        if (count > byteUni.length) {\n            throw new RangeError('ArgumentOutOfRange_Count');\n        }\n        var byte16 = new Uint16Array(count);\n        var out = '';\n        for (var i = 0; i < count && i < byteUni.length; i++) {\n            byte16[i] = byteUni[index++];\n        }\n        out = String.fromCharCode.apply(null, byte16);\n        return out;\n    };\n    /**\n     * To clear the encoding instance\n     * @return {void}\n     */\n    Encoding.prototype.destroy = function () {\n        this.emitBOM = undefined;\n        this.encodingType = undefined;\n    };\n    return Encoding;\n}());\nexport { Encoding };\n/**\n * To check the object is null or undefined and throw error if it is null or undefined\n * @param {Object} value - object to check is null or undefined\n * @return {boolean}\n * @throws {ArgumentException} - if the value is null or undefined\n * @private\n */\nexport function validateNullOrUndefined(value, message) {\n    if (value === null || value === undefined) {\n        throw new Error('ArgumentException: ' + message + ' cannot be null or undefined');\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}